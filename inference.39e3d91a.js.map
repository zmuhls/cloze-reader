{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,uB,I,G,E,E,O,C,4B,I,G,E,E,O,C,gB,I,G,I,E,E,SC0BM,SAAU,IACd,OAAO,OAAO,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,cAClC,AAA6B,4BAA7B,OAAO,QAAQ,CAAC,QAAQ,EACxB,AAA6B,UAA7B,OAAO,QAAQ,CAAC,QAAQ,AACjC,CAOM,SAAU,IACd,IAAM,EAAS,IAGT,EAAkB,aAAa,OAAO,CAAC,sBACvC,EAAiB,CAAA,CAAQ,GACP,EAAiB,UAAU,CAAC,WAC5B,EAAiB,MAAM,CAAG,GAG5C,EAAa,KApCO,wGAuCpB,EAAS,EAAS,EAAc,EAAiB,EAAmB,EAQ1E,MANA,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,4BAA6B,CACpC,kBAAmB,EACnB,aAAc,CAAC,GAAU,EACzB,UAAW,EAAO,SAAS,CAAC,EAAG,GAAK,KACrC,GAEM,CACL,mBAAoB,EACpB,oBAAqB,CACtB,CACH,CAOM,SAAU,IAEd,GAAI,IACF,MAAO,CAAA,EAGT,IAAM,EAAkB,aAAa,OAAO,CAAC,sBAC7C,MAAO,CAAA,CAAQ,GACR,EAAiB,UAAU,CAAC,WAC5B,EAAiB,MAAM,CAAG,EACnC,CASM,SAAU,EAAc,CAAW,EAEvC,GAAI,IAEF,MADA,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,iDACF,CAAA,EAGT,IAAM,EAAa,EAAI,IAAI,SAC3B,EAAI,CAAA,GAAc,EAAW,UAAU,CAAC,SAAA,GAAa,EAAW,MAAM,CAAG,KACvE,aAAa,OAAO,CAAC,qBAAsB,GACpC,CAAA,EAGX,C,G,E,Q,S,C,C,C,E,E,E,O,C,W,I,GC7FM,SAAU,EAAS,CAAe,CAAE,CAAU,EAClD,IAAM,EAAY,IAAI,OAAO,WAAW,GAExC,GADA,QAAQ,GAAG,CAAC,CAAA,OAAA,EAAU,EAAS,EAAA,EAAK,EAAA,CAAS,EACzC,AAAS,KAAA,IAAT,EACF,GAAI,CAEF,IAAM,EAAW,KAAK,SAAS,CAAC,EAAM,CAAC,EAAK,IAC1C,AAAI,aAAiB,YACZ,CAAA,aAAA,EAAgB,EAAM,OAAO,CAAA,EAAG,EAAM,EAAE,CAAG,IAAM,EAAM,EAAE,CAAG,GAAE,CAAA,CAAG,CAGnE,EACN,GACH,QAAQ,GAAG,CAAC,EACd,CAAE,MAAO,EAAO,CACd,QAAQ,GAAG,CAAC,+BAAgC,GAC5C,QAAQ,GAAG,CAAC,mBAAoB,EAClC,CAEJ,C,G,E,Q,S,C,C,C,E,E,E,O,C,4B,I,G,E,E,O,C,Y,I,G,E,E,O,C,a,I,G,E,E,O,C,mB,I,G,I,E,E,S,E,E,SCFA,IAAM,EAAiC,CACrC,MAAO,CAAA,EACP,QAAS,GACT,IAAK,SAAS,CAAG,CAAE,CAAK,EACtB,GAAI,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,MAAM,EAAI,IAAI,CAAC,OAAO,CAAE,CAClD,IAAM,EAAY,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,AAC5C,QAAO,IAAI,CAAC,KAAK,CAAC,EAAU,AAC9B,CACA,IAAI,CAAC,KAAK,CAAC,EAAI,CAAG,CAAE,MAAA,EAAO,UAAW,KAAK,GAAG,EAAE,EAChD,GAAI,CAAE,aAAa,OAAO,CAAC,iBAAkB,KAAK,SAAS,CAAC,IAAI,CAAC,KAAK,EAAI,CAC1E,MAAO,EAAG,CAAE,QAAQ,IAAI,CAAC,uCAAwC,EAAI,CACvE,EACA,IAAK,SAAS,CAAG,EACf,IAAM,EAAO,IAAI,CAAC,KAAK,CAAC,EAAI,CAC5B,GAAI,CAAC,EAAM,OAAO,KAClB,GAAI,KAAK,GAAG,GAAK,EAAK,SAAS,CAAG,MAAqB,CACrD,OAAO,IAAI,CAAC,KAAK,CAAC,EAAI,CACtB,GAAI,CAAE,aAAa,OAAO,CAAC,iBAAkB,KAAK,SAAS,CAAC,IAAI,CAAC,KAAK,EAAI,CAC1E,MAAO,EAAG,CAAE,QAAQ,IAAI,CAAC,yCAA0C,EAAI,CACvE,OAAO,IACT,CACA,OAAO,EAAK,KAAK,AACnB,EACA,KAAM,WACJ,GAAI,CACF,IAAM,EAAQ,aAAa,OAAO,CAAC,iBAC/B,CAAA,GAAO,CAAA,IAAI,CAAC,KAAK,CAAG,KAAK,KAAK,CAAC,EAAnC,CACF,CAAE,MAAO,EAAG,CAAE,QAAQ,IAAI,CAAC,yCAA0C,GAAI,IAAI,CAAC,KAAK,CAAG,CAAA,CAAI,CAC5F,CACD,EAaK,SAAU,EAAiB,CAAe,CAAE,CAAa,EAC7D,IAAM,EAAoB,EAAE,CAC5B,GAAI,AAAiB,IAAjB,EAAM,MAAM,EAAU,AAAU,IAAV,EAAa,OAAO,EAE9C,IAAM,EAAgB,IAAI,IAAI,CAC5B,MAAO,IAAK,KAAM,MAAO,KAAM,MAAO,KAAM,KAAM,KAAM,KAAM,MAAO,OAAQ,QAC7E,KAAM,OAAQ,KAAM,KAAM,KAAM,MAAO,MAAO,OAAQ,KAAM,OAAQ,QAAS,OAC7E,MAAO,MAAO,KAAM,OAAQ,MAAO,OAAQ,QAAS,QAAS,SAAU,MAAO,QAC9E,MAAO,QAAS,OAAQ,OAAQ,QAAS,MAAO,OAAQ,QAAS,OAAQ,QACzE,QAAS,KAAM,IAAK,KAAM,MAAO,KAAM,MAAO,OAAQ,KAAM,KAC7D,EAEK,EAA4B,EAAM,GAAG,CAAC,CAAC,EAAM,KACjD,IACI,EADE,EAAY,EAAK,WAAW,GAAG,OAAO,CAAC,SAAU,IAUvD,OARA,EADY,EACH,AAAmB,EAAnB,EAAU,MAAM,CACrB,EAAc,GAAG,CAAC,IACpB,CAAA,GAAS,EADX,EAGI,EAAQ,GAAK,CAAI,CAAC,EAAE,GAAK,CAAI,CAAC,EAAE,CAAC,WAAW,IAAM,CAAI,CAAC,EAAE,CAAC,KAAK,CAAC,UAClE,CAAA,GAAS,CAAA,EAGJ,CAAE,MAAA,EAAO,MADhB,GAAS,AAAgB,EAAhB,KAAK,MAAM,EACC,CACvB,GAEA,EAAY,IAAI,CAAC,CAAC,EAAG,IAAM,EAAE,KAAK,CAAG,EAAE,KAAK,EAE5C,IAAM,EAAc,KAAK,GAAG,CAAC,EAAO,EAAM,MAAM,EAC1C,EAAoB,KAAK,GAAG,CAAC,AAAc,EAAd,EAAiB,EAAM,MAAM,EAC1D,EAAgB,EAAY,KAAK,CAAC,EAAG,GAE3C,KAAO,EAAQ,MAAM,CAAG,GAAe,EAAc,MAAM,CAAG,GAAG,CAC/D,IAAM,EAAc,KAAK,KAAK,CAAC,KAAK,MAAM,GAAK,EAAc,MAAM,EAC7D,EAAe,EAAc,MAAM,CAAC,EAAa,EAAE,CAAC,EAAE,CAC5D,EAAQ,IAAI,CAAC,EAAa,KAAK,CACjC,CAEA,OAAO,EAAQ,IAAI,CAAC,CAAC,EAAG,IAAM,EAAI,EACpC,CAjDA,EAAe,IAAI,GA0EZ,IAAI,EAA8B,CAAC,EAAE,CAAE,EAAE,CAAC,CACtC,EAA8B,CAAC,EAAE,CAAE,EAAE,CAAC,CACtC,EAAQ,EACR,EAAc,EACd,EAAiB,EACjB,EAA4B,IAAI,IAChC,EAAiE,EAAE,CAe1E,EAAsC,KAEpC,SAAU,EAA0B,CAAyB,EACjE,EAAc,CAChB,CAiBM,SAAU,IACd,GAAI,CAAC,EAAa,YAChB,QAAQ,KAAK,CAAC,0DAIhB,GAAM,CAAA,SAAE,CAAQ,CAAA,UAAE,CAAS,CAAA,UAAE,CAAS,CAAA,QAAE,CAAO,CAAA,WAAE,CAAU,CAAE,CAAG,EAE1D,EAAc,CAAe,CAAC,EAAE,CAAC,MAAM,CAAG,CAAe,CAAC,EAAE,CAAC,MAAM,CAIzE,GAHA,EAAU,WAAW,CAAG,CAAA,MAAA,EAAS,EAAK,UAAA,EAAM,EAAW,OAAA,CAAS,CAChE,EAAS,SAAS,CAAG,GAEjB,AAA8B,IAA9B,CAAe,CAAC,EAAE,CAAC,MAAM,EAAU,AAA8B,IAA9B,CAAe,CAAC,EAAE,CAAC,MAAM,CAAQ,CACtE,EAAS,SAAS,CAAG,2DACrB,EAAU,QAAQ,CAAG,CAAA,EACrB,EAAQ,QAAQ,CAAG,CAAA,EAEnB,MACF,CAEA,IAAK,IAAI,EAAO,EAAG,EAAO,EAAG,IAAQ,CACnC,GAAI,AAAiC,IAAjC,CAAe,CAAC,EAAK,CAAC,MAAM,CAAQ,SAExC,IAAM,EAAmB,SAAS,aAAa,CAAC,IAChD,CAAA,EAAiB,SAAS,CAAG,mDAC7B,EAAiB,KAAK,CAAC,QAAQ,CAAG,OAClC,EAAiB,KAAK,CAAC,YAAY,CAAG,aACtC,EAAS,WAAW,CAAC,GAErB,CAAe,CAAC,EAAK,CAAC,OAAO,CAAC,CAAC,EAAM,KACnC,GAAI,CAAe,CAAC,EAAK,CAAC,QAAQ,CAAC,GAAM,CACvC,IAAM,EAAQ,SAAS,aAAa,CAAC,QACrC,CAAA,EAAM,IAAI,CAAG,OACb,EAAM,OAAO,CAAC,KAAK,CAAG,OAAO,GAC7B,EAAM,OAAO,CAAC,SAAS,CAAG,OAAO,GACjC,EAAM,WAAW,CAAG,QAEpB,EAAM,SAAS,CAAG,iQAGlB,EAAM,gBAAgB,CAAC,UAAW,AAAC,IACZ,IAAjB,EAAE,GAAG,CAAC,MAAM,GACd,EAAM,SAAS,CAAC,GAAG,CAAC,6BACpB,WAAW,IAAM,EAAM,SAAS,CAAC,MAAM,CAAC,6BAA8B,KAE1E,GAEA,EAAM,gBAAgB,CAAC,QAAS,KAE9B,EAAU,QAAQ,CAAG,CADH,MAAM,IAAI,CAAC,EAAS,gBAAgB,CAAmB,uBAAuB,KAAK,CAAC,AAAA,GAAK,AAAmB,KAAnB,EAAE,KAAK,CAAC,IAAI,GAEzH,GACA,EAAiB,WAAW,CAAC,GAC7B,EAAiB,WAAW,CAAC,SAAS,cAAc,CAAC,MAErD,EAAM,gBAAgB,CAAC,QAAS,KAC9B,GAAI,CAAC,EAAa,OAClB,IAAM,EAAe,OAAO,EAAM,OAAO,CAAC,SAAS,EAC7C,EAAU,OAAO,EAAM,OAAO,CAAC,KAAK,EACpC,EAAW,CAAA,EAAG,EAAY,CAAA,EAAI,EAAA,CAAS,AAE7C,CAAA,EAAY,OAAO,CAAC,QAAQ,CAAG,GAAkB,GAAK,EAAa,GAAG,CAAC,GAEvE,EAAY,OAAO,CAAC,OAAO,CAAG,KAC5B,GAAI,EAAiB,GAAK,CAAC,EAAa,GAAG,CAAC,GAAW,CACrD,IAAM,EAAe,CAAe,CAAC,EAAa,CAAC,EAAQ,CAE3D,GAAI,EAAc,CAChB,IAAM,EAAW,CAAA,aAAA,EAAgB,CAAY,CAAC,EAAE,CAAA,UAAA,EAAa,EAAa,MAAM,CAAA,CAAA,CAAG,CAC7E,EAAU,SAAS,aAAa,CAAC,MACvC,CAAA,EAAQ,SAAS,CAAG,6EACpB,EAAQ,SAAS,CAAG;A;A;AAGX,uBAAA,EAAA,EAAA;A;A;AAGR,gBAAA,CAAA,CACD,SAAS,IAAI,CAAC,WAAW,CAAC,GAE1B,IAAM,EAAY,IAAM,SAAS,IAAI,CAAC,WAAW,CAAC,GAClD,EAAQ,aAAa,CAAC,WAAW,iBAAiB,QAAS,GAC3D,EAAQ,gBAAgB,CAAC,QAAS,AAAC,IAC7B,EAAE,MAAM,GAAK,GAAS,GAC5B,GAEA,IACI,GAAa,CAAA,EAAY,OAAO,CAAC,WAAW,CAAG,CAAA,MAAA,EAAS,EAAc,CAAA,CAAG,AAAH,EAC1E,EAAa,GAAG,CAAC,GACjB,EAAM,SAAS,CAAC,GAAG,CAAC,gBAChB,GAAa,CAAA,EAAY,OAAO,CAAC,QAAQ,CAAG,GAAkB,GAAK,EAAa,GAAG,CAAC,EAAxF,CACF,CACF,CACF,CACF,EACF,KAAO,CACL,IAAM,EAAW,SAAS,aAAa,CAAC,OACxC,CAAA,EAAS,WAAW,CAAG,EAAO,IAC9B,EAAS,SAAS,CAAG,kBACrB,EAAiB,WAAW,CAAC,EAC/B,CACF,EACF,CAEA,IAAM,EAAqB,CAAe,CAAC,EAAE,CAAC,MAAM,CAAG,CAAe,CAAC,EAAE,CAAC,MAAM,AAChF,CAAA,EAAU,QAAQ,CAAG,AAAuB,IAAvB,EACrB,EAAQ,QAAQ,CAAG,GAAkB,GAAK,AAAuB,IAAvB,EAC1C,EAAW,WAAW,CAAG,GAGrB,AAAsB,YAAtB,OAAO,YACT,aAIF,WAAW,KACL,AAAkB,aAAlB,OAAO,QAA0B,OAAO,qBAAqB,EAC/D,OAAO,qBAAqB,EAEhC,EAAG,IACL,CAKM,SAAU,IACd,GAAI,CAAC,EAAa,YAChB,QAAQ,KAAK,CAAC,wDAGhB,GAAM,CAAA,SAAE,CAAQ,CAAA,WAAE,CAAU,CAAA,UAAE,CAAS,CAAA,kBAAE,CAAiB,CAAE,CAAG,EAE/D,EAAQ,EACR,EAAc,EACd,EAAiB,EACjB,EAAa,KAAK,GAClB,CAAe,CAAC,EAAE,CAAG,EAAE,CACvB,CAAe,CAAC,EAAE,CAAG,EAAE,CACvB,CAAe,CAAC,EAAE,CAAG,EAAE,CACvB,CAAe,CAAC,EAAE,CAAG,EAAE,CACvB,EAAgB,EAAE,CAEd,GAAU,CAAA,EAAS,SAAS,CAAG,EAAnC,EACI,GAAY,CAAA,EAAW,WAAW,CAAG,EAAzC,EACI,GAAW,CAAA,EAAU,WAAW,CAAG,EAAvC,EACI,GAAmB,CAAA,EAAkB,SAAS,CAAG,EAArD,EAEI,AAAqB,YAArB,OAAO,WACT,YAEF,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,6BACX,CAQO,eAAe,EAAW,EAA2B,CAAA,CAAK,EAC/D,GAAI,CAAC,EAAa,YAChB,QAAQ,KAAK,CAAC,yDAGhB,GAAM,CAAA,SAAE,CAAQ,CAAA,UAAE,CAAS,CAAA,UAAE,CAAS,CAAA,QAAE,CAAO,CAAA,WAAE,CAAU,CAAA,kBAAE,CAAiB,CAAE,CAAG,EAEnF,EAAiB,EACb,GAAS,CAAA,EAAQ,WAAW,CAAG,CAAA,MAAA,EAAS,EAAc,CAAA,CAAG,AAAH,EACtD,GAAW,CAAA,EAAU,QAAQ,CAAG,CAAA,CAApC,EACI,GAAS,CAAA,EAAQ,QAAQ,CAAG,CAAA,CAAhC,EACI,GAAU,CAAA,EAAS,SAAS,CAAG,uLAAnC,EACI,GAAY,CAAA,EAAW,WAAW,CAAG,EAAzC,EACA,EAAa,KAAK,GACd,AAAqB,YAArB,OAAO,WACT,YAGE,GACA,CAAA,EAAkB,SAAS,CAAG,EADlC,EAIA,IAAM,EAAW,aAAa,OAAO,CAAC,kBAAoB,GACpD,EAAS,aAAa,OAAO,CAAC,gBAAkB,GAChD,EAAU,aAAa,OAAO,CAAC,iBAAmB,GAEpD,EAAW,CAAA,QAAA,EAAW,GAAY,MAAK,CAAA,EAAI,GAAU,MAAK,CAAA,EAAI,GAAW,MAAA,CAAO,CAM/E,GAAa,GAAW,IAAW,IACtC,EAAW,CAAA,eAAA,EAAkB,KAAK,GAAG,GAAE,CAAA,EAAI,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAA,CAAI,CACpF,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,yDAA0D,CAAE,SAAA,CAAQ,IAG/E,IAAM,EAAgB,EAAe,GAAG,CAAC,GAGzC,GAAI,AAAC,IAAmB,GAAkB,EAAS,UAAU,CAAC,mBA6EvD,CACD,EACF,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,8CAA+C,CAAE,SAAA,CAAQ,GAElE,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,0DAA2D,CAAE,SAAA,CAAQ,GAGlF,IAAI,EAAwE,KAE5E,GAAI,CAIF,GAAI,CAFJ,CAAA,EAAqB,MAAM,AAAA,CAAA,EAAA,EAAA,qBAAA,AAAA,EAAsB,EAAU,EAAQ,EAAS,EAAE,CAAA,GAEnD,AAAyC,IAAzC,EAAmB,UAAU,CAAC,MAAM,CAAQ,CACjE,GAAU,CAAA,EAAS,SAAS,CAAG,yNAAnC,EACI,GAAW,CAAA,EAAU,QAAQ,CAAG,CAAA,CAApC,EACI,GAAS,CAAA,EAAQ,QAAQ,CAAG,CAAA,CAAhC,EACI,AAAqB,YAArB,OAAO,WACT,YAEF,MACF,CAEA,GAAI,CACF,EAAe,GAAG,CAAC,EAAU,KAAK,SAAS,CAAC,IAC5C,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,0BAA2B,CAAE,SAAA,CAAQ,EAChD,CAAE,MAAO,EAAG,CACV,QAAQ,IAAI,CAAC,oCAAqC,EACpD,CAOA,GALA,CAAe,CAAC,EAAE,CAAG,EAAmB,UAAU,CAAC,EAAE,CAAC,KAAK,CAAC,OAAO,MAAM,CAAC,AAAC,GAAc,EAAE,MAAM,CAAG,GACpG,CAAe,CAAC,EAAE,CAAG,EAAmB,UAAU,CAAC,MAAM,CAAG,EAC1D,EAAmB,UAAU,CAAC,EAAE,CAAC,KAAK,CAAC,OAAO,MAAM,CAAC,AAAC,GAAc,EAAE,MAAM,CAAG,GAAK,EAAE,CAGpF,GAAqB,GAAsB,EAAmB,QAAQ,CAAE,CAGpE,CADqB,EAAc,IAAI,CAAC,AAAA,GAAQ,EAAK,EAAE,GAAK,EAAoB,QAAS,CAAC,EAAE,IAE9F,EAAc,OAAO,CAAC,EAAmB,QAAQ,EAC7C,EAAc,MAAM,CAAG,GACzB,EAAc,GAAG,IAIrB,IAAI,EAAc,EACd,CAAA,EAAc,MAAM,CAAG,IACvB,EAAc,sIACd,EAAc,KAAK,CAAC,EAAG,GAAG,OAAO,CAAC,AAAA,IAC9B,GAAe,CAAA,8CAAA,EAAiD,EAAK,EAAE,CAAA,iEAAA,EAAoE,EAAK,KAAK,CAAA,IAAA,EAAO,EAAK,MAAM,CAAA,SAAA,CAAW,AACtL,GACA,GAAe,SAGnB,EAAkB,SAAS,CAAG;A;AAE0C,8EAAA,EAAA,EAAmB,QAAQ,CAAC,EAAE,CAAA,iEAAA,EAAoE,EAAmB,QAAQ,CAAC,KAAK,CAAA,aAAA,EAAgB,EAAmB,QAAQ,CAAC,MAAM,CAAA,MAAA,EAAS,EAAmB,QAAQ,CAAC,EAAE,CAA5N;A;AAElE,YAAA,EAAA;AACL,QAAA,CAAA,CACD,WAAW,KACe,aAAlB,OAAO,QAA2B,OAAe,qBAAqB,EAEtE,AADqB,EAAkB,gBAAgB,CAAC,gBAC3C,OAAO,CAAC,AAAA,GAAO,OAAe,qBAAqB,CAAC,GAEzE,EAAG,IACP,CACF,CAAE,MAAO,EAAO,CACd,QAAQ,KAAK,CAAC,0BAA2B,GACrC,GAAU,CAAA,EAAS,SAAS,CAAG,oLAAnC,EACI,GAAW,CAAA,EAAU,QAAQ,CAAG,CAAA,CAApC,EACI,GAAS,CAAA,EAAQ,QAAQ,CAAG,CAAA,CAAhC,EACI,AAAqB,YAArB,OAAO,WACT,YAEF,MACF,CAEA,GAAI,CAAC,EAAoB,MAEzB,CAAA,CAAe,CAAC,EAAE,CAAC,MAAM,CAAG,EAC5B,CAAe,CAAC,EAAE,CAAC,MAAM,CAAG,EAC5B,IAAM,EAAa,CAAe,CAAC,EAAE,CAAC,MAAM,CAAG,CAAe,CAAC,EAAE,CAAC,MAAM,CAElE,EAAoB,KAAK,GAAG,CAAC,EADT,KAAK,KAAK,CAAC,AAAa,GAAb,IAGrC,GAAI,CAAe,CAAC,EAAE,CAAC,MAAM,CAAG,EAAG,CACjC,IAAM,EAAkB,CAAe,CAAC,EAAE,CAAC,MAAM,CAAG,EAClD,KAAK,KAAK,CAAC,EAAqB,CAAA,CAAe,CAAC,EAAE,CAAC,MAAM,CAAG,CAAA,GAC5D,EAEF,AAD2B,EAAiB,CAAe,CAAC,EAAE,CAAE,GAC7C,OAAO,CAAC,AAAA,GAAK,CAAe,CAAC,EAAE,CAAC,IAAI,CAAC,GAC1D,CACA,GAAI,CAAe,CAAC,EAAE,CAAC,MAAM,CAAG,EAAG,CACjC,IAAM,EAAmB,EAAoB,CAAe,CAAC,EAAE,CAAC,MAAM,CAEtE,AAD2B,EAAiB,CAAe,CAAC,EAAE,CAAE,GAC7C,OAAO,CAAC,AAAA,GAAK,CAAe,CAAC,EAAE,CAAC,IAAI,CAAC,GAC1D,CAEA,GAAK,CAAe,CAAC,EAAE,CAAC,MAAM,CAAG,CAAe,CAAC,EAAE,CAAC,MAAM,GAAM,EAAG,CAC7D,GAAU,CAAA,EAAS,SAAS,CAAG,6JAAnC,EACI,GAAW,CAAA,EAAU,QAAQ,CAAG,CAAA,CAApC,EACI,GAAS,CAAA,EAAQ,QAAQ,CAAG,CAAA,CAAhC,EACI,AAAqB,YAArB,OAAO,WACT,YAEF,MACF,CAEA,GACF,KA3LoF,CAChF,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,6BAA8B,CAAE,SAAA,CAAQ,GACjD,IAAM,EAAc,KAAK,KAAK,CAAC,GAC9B,GAAI,GAAe,EAAY,UAAU,EAAI,MAAM,OAAO,CAAC,EAAY,UAAU,EAAG,CACjF,IAAM,EAAc,CAChB,WAAY,EAAY,UAAU,CAClC,SAAU,EAAY,QAAQ,EAAI,IACrC,EACD,GAAI,GAAqB,EAAY,QAAQ,CAAE,CAGvC,CADqB,EAAc,IAAI,CAAC,AAAA,GAAQ,EAAK,EAAE,GAAK,EAAY,QAAS,CAAC,EAAE,IAEtF,EAAc,OAAO,CAAC,EAAY,QAAQ,EACtC,EAAc,MAAM,CAAG,GACzB,EAAc,GAAG,IAIrB,IAAI,EAAc,EACd,CAAA,EAAc,MAAM,CAAG,IACvB,EAAc,sIACd,EAAc,KAAK,CAAC,EAAG,GAAG,OAAO,CAAC,AAAA,IAC9B,GAAe,CAAA,8CAAA,EAAiD,EAAK,EAAE,CAAA,iEAAA,EAAoE,EAAK,KAAK,CAAA,IAAA,EAAO,EAAK,MAAM,CAAA,SAAA,CAAW,AACtL,GACA,GAAe,SAEnB,EAAkB,SAAS,CAAG;A;AAEmD,2FAAA,EAAA,EAAY,QAAQ,CAAC,EAAE,CAAA,iEAAA,EAAoE,EAAY,QAAQ,CAAC,KAAK,CAAA,aAAA,EAAgB,EAAY,QAAQ,CAAC,MAAM,CAAA,MAAA,EAAS,EAAY,QAAQ,CAAC,EAAE,CAAhM;A;AAE3E,gBAAA,EAAA;AACL,YAAA,CAAA,CACD,WAAW,KACe,aAAlB,OAAO,QAA2B,OAAe,qBAAqB,EAEtE,AADqB,EAAkB,gBAAgB,CAAC,gBAC3C,OAAO,CAAC,AAAA,GAAO,OAAe,qBAAqB,CAAC,GAEzE,EAAG,IACP,CACA,CAAe,CAAC,EAAE,CAAG,EAAY,UAAU,CAAC,EAAE,CAAC,KAAK,CAAC,OAAO,MAAM,CAAC,AAAC,GAAc,EAAE,MAAM,CAAG,GAC7F,CAAe,CAAC,EAAE,CAAG,EAAY,UAAU,CAAC,MAAM,CAAG,EACnD,EAAY,UAAU,CAAC,EAAE,CAAC,KAAK,CAAC,OAAO,MAAM,CAAC,AAAC,GAAc,EAAE,MAAM,CAAG,GAAK,EAAE,CAEjF,CAAe,CAAC,EAAE,CAAC,MAAM,CAAG,EAC5B,CAAe,CAAC,EAAE,CAAC,MAAM,CAAG,EAC5B,IAAM,EAAa,CAAe,CAAC,EAAE,CAAC,MAAM,CAAG,CAAe,CAAC,EAAE,CAAC,MAAM,CAElE,EAAoB,KAAK,GAAG,CAAC,EADT,KAAK,KAAK,CAAC,AAAa,GAAb,IAGrC,GAAI,CAAe,CAAC,EAAE,CAAC,MAAM,CAAG,EAAG,CACjC,IAAM,EAAkB,CAAe,CAAC,EAAE,CAAC,MAAM,CAAG,EAClD,KAAK,KAAK,CAAC,EAAqB,CAAA,CAAe,CAAC,EAAE,CAAC,MAAM,CAAG,CAAA,GAC5D,EAEF,AAD2B,EAAiB,CAAe,CAAC,EAAE,CAAE,GAC7C,OAAO,CAAC,AAAA,GAAK,CAAe,CAAC,EAAE,CAAC,IAAI,CAAC,GAC1D,CACA,GAAI,CAAe,CAAC,EAAE,CAAC,MAAM,CAAG,EAAG,CACjC,IAAM,EAAmB,EAAoB,CAAe,CAAC,EAAE,CAAC,MAAM,CAEtE,AAD2B,EAAiB,CAAe,CAAC,EAAE,CAAE,GAC7C,OAAO,CAAC,AAAA,GAAK,CAAe,CAAC,EAAE,CAAC,IAAI,CAAC,GAC1D,QAEA,AAAK,CAAe,CAAC,EAAE,CAAC,MAAM,CAAG,CAAe,CAAC,EAAE,CAAC,MAAM,GAAM,GAC1D,GAAU,CAAA,EAAS,SAAS,CAAG,iLAAnC,EACI,GAAW,CAAA,EAAU,QAAQ,CAAG,CAAA,CAApC,EACI,GAAS,CAAA,EAAQ,QAAQ,CAAG,CAAA,CAAhC,EACI,AAAqB,YAArB,OAAO,WACT,YAEK,OAGT,IACO,EACV,CACG,QAAQ,IAAI,CAAC,sBAAuB,EAAU,4BAEpD,CA+GF,CAMO,eAAe,EAAiB,EAAW,CAAA,CAAK,EACrD,GAAI,CAAC,EAAa,YAChB,QAAQ,KAAK,CAAC,+DAGhB,GAAM,CAAA,SAAE,CAAQ,CAAA,UAAE,CAAS,CAAA,QAAE,CAAO,CAAA,WAAE,CAAU,CAAE,CAAG,CAEjD,AAAqB,CAAA,YAArB,OAAO,WACT,YAQF,IAAM,EAAS,MAAM,IAAI,CAAC,EAAS,gBAAgB,CAAmB,uBAClE,EAAe,EACf,EAAa,EAEjB,EAAO,OAAO,CAAC,AAAA,IACb,IACA,IAAM,EAAe,OAAO,EAAM,OAAO,CAAC,SAAS,EAAI,KACjD,EAAU,OAAO,EAAM,OAAO,CAAC,KAAK,EAEpC,EAAe,CAAe,CAAC,EAAa,CAAC,EAAQ,CACrD,EAAc,EAAM,KAAK,CAAC,IAAI,GAE9B,EAAoB,EAAa,OAAO,CAAC,aAAc,IAAI,WAAW,GACtE,EAAmB,EAAY,WAAW,GAE1C,EAAW,SAAS,aAAa,CAAC,OACxC,CAAA,EAAS,SAAS,CAAG,4BAEjB,IAAqB,GACvB,IACA,EAAS,WAAW,CAAG,EAAe,IACtC,EAAS,SAAS,CAAC,GAAG,CAAC,oBAEvB,EAAS,WAAW,CAAG,CAAA,EAAG,EAAW,EAAA,EAAK,EAAY,EAAA,CAAI,CAC1D,EAAS,SAAS,CAAC,GAAG,CAAC,iBAGzB,EAAM,aAAa,EAAE,aAAa,EAAU,GAC5C,EAAM,MAAM,EACd,GAEA,IAAM,EAAe,KAAK,IAAI,CAAC,AAAa,GAAb,GAC/B,EAAW,SAAS,CAAC,MAAM,CAAC,iBAAkB,gBAE1C,EACF,EAAW,WAAW,CAAG,CAAA,mBAAA,EAAsB,EAAY,CAAA,EAAI,EAAU,SAAA,CAAW,CAGpF,EAAW,WAAW,CAAG,CAAA,EAAG,EAAY,CAAA,EAAI,EAAU,SAAA,CAAW,CACjE,EAAW,SAAS,CAAC,GAAG,CAAC,GAAgB,EAAe,iBAAmB,eAAgB,0BAGzF,GAAgB,GAChB,IACA,IACI,GAAY,CAAA,EAAW,WAAW,EAAI,CAAA,gBAAA,EAAmB,EAAK,MAAA,EAAS,EAAW,uBAAA,CAAyB,AAAzB,GAElF,GAAY,CAAA,EAAW,WAAW,EAAI,wCAAA,EAG1C,GAAW,CAAA,EAAU,QAAQ,CAAG,CAAA,CAApC,EACI,GAAS,CAAA,EAAQ,QAAQ,CAAG,CAAA,CAAhC,EAEI,GAAgB,EAClB,WAAW,IAAM,EAAW,CAAA,GAAQ,KAEpC,WAAW,IAAM,EAAW,CAAA,GAAO,IAEvC,C,G,E,Q,S,C,C,C,MChUI,EAAgC,EAAuB,EAAyB,EAChF,EAA8B,EAAwB,E,E,E,O,C,wB,I,G,I,E,E,S,E,E,S,E,E,S,E,E,SA1QnD,eAAe,EACpB,EAA0B,IAAI,CAC9B,EAAwB,IAAI,CAC5B,EAAyB,IAAI,CAC7B,EAA6B,EAAE,EAG/B,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,6BAA8B,CAAE,SAAA,EAAU,OAAA,EAAQ,QAAA,EAAS,QAAS,EAAiB,MAAM,CAAG,CAAC,GAOxG,IAAM,EAAiB,CAAA,CAAQ,AAAA,CAAA,EAAA,EAAA,oBAAA,AAAA,IAAuB,kBAAkB,CAClE,EAAmB,AAAA,CAAA,EAAA,EAAA,yBAAA,AAAA,IACnB,EAAgB,OAAO,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,aAkBxD,GAhBA,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,oBAAqB,CAC5B,eAAA,EACA,iBAAA,EACA,cAAA,EACA,SAAU,OAAO,QAAQ,CAAC,QAAQ,CAClC,aAAc,AAAA,CAAA,EAAA,EAAA,oBAAA,AAAA,IAAuB,kBAAkB,CAAC,SAAS,CAAC,EAAG,GAAK,MAC1E,cA5EmB,CAAA,EA6EnB,kBAd0B,CAAA,CAe3B,GAQG,CAAC,EAAyD,KAExD,EADJ,QAAQ,IAAI,CAAC,qEAEb,IAAI,EAAmB,CAAE,MAAO,mBAAoB,OAAQ,YAAa,GAAI,CAAC,EAoB9E,MAlBI,AAAa,cAAb,GACF,EAAqB,CAArB;A;AAE+V,oWAAA,CAAA,CAC/V,EAAmB,CAAE,MAAO,0BAA2B,OAAQ,kBAAmB,GAAI,CAAC,GAC9E,AAAa,YAAb,GACT,EAAqB,CAArB;A;AAE+Y,oZAAA,CAAA,CAC/Y,EAAmB,CAAE,MAAO,qBAAsB,OAAQ,kBAAmB,GAAI,CAAC,IAGlF,EAAqB,CAArB;A;AAEyY,8YAAA,CAAA,CACzY,EAAmB,CAAE,MAAO,4BAA6B,OAAQ,kBAAmB,GAAI,CAAC,GAGpF,CACL,WAAY,EAAmB,KAAK,CAAC,OAAO,MAAM,CAAC,AAAA,GAAK,EAAE,IAAI,GAAG,MAAM,CAAG,GAC1E,SAAU,CACX,CACH,CAGA,IAAK,IAAI,EAAU,EAAG,EA1DF,EA0DyB,IAAW,KA4BlD,EA3BJ,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,iBAAiB,EAAU,0BAAuC,EAAiB,IAAI,CAAC,OAAO,EAExG,IAAM,EAAa,EAAE,CAGrB,GAFI,GAAQ,EAAW,IAAI,CAAC,CAAA,WAAA,EAAc,EAAM,CAAA,CAAG,EAE/C,EACF,GAAI,EAAS,QAAQ,CAAC,KAAM,CAC1B,IAAM,EAAe,EAAS,KAAK,CAAC,IAAI,CAAC,EAAE,CACvC,GACF,EAAW,IAAI,CAAC,CAAA,+BAAA,EAAkC,EAAY,CAAA,CAAG,EACjE,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,CAAA,oBAAA,EAAuB,EAAY,iBAAA,EAAoB,EAAQ,EAAA,CAAI,GAE5E,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,CAAA,8CAAA,EAAiD,EAAQ,4BAAA,CAA8B,CAEpG,MACE,EAAW,IAAI,CAAC,CAAA,iBAAA,EAAoB,EAAQ,CAAA,CAAG,EAInD,GAAI,EAAS,CACX,IAAM,EAAgB,SAAS,EAC3B,CAAC,MAAM,IACP,EAAW,IAAI,CAAC,CAAA,SAAA,EAAY,EAAgB,EAAC,UAAA,CAAY,CAE/D,CAEA,IAAI,EAAc,EAAW,IAAI,CAAC,IAG9B,CAAA,EAAW,MAAM,CAAG,GACtB,EAAuB,CAAA,uBAAA,EAA0B,EAAA,CAAa,CAC9D,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,8DAIT,EAAuB,0LACvB,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,oFAGX,IAAI,EAAoB,EACpB,CAAA,EAAU,GACZ,CAAA,EAAoB,CAAA,iBAAA,EAAoB,EAAU,EAAC,qEAAA,CAAuE,AAAvE,EAEjD,EAAiB,MAAM,CAAG,GAC5B,CAAA,GAAqB,CAAA,8BAAA,EAAiC,EAAiB,IAAI,CAAC,MAAK,CAAA,CAAG,AAAH,EAiBnF,IAAM,EAAgC,CACpC,CAAE,KAAM,SAAU,QAAS,iZAAiZ,EAC5a,CAAE,KAAM,OAAQ,QAhBA,CAAlB;AACF,EAAA,EAAuB,CAAA,+BAAA,EAAkC,EAAoB,CAAA,CAAG,CAAG;AACnF,EAAA;A;A;A;A;A;A;A;A;A;AAU4H,6HAAA,CAAA,AAItF,EACnC,CAED,GAAI,CAEF,IAAM,EAAc,AAAuB,IAAvB,EAAY,MAAM,CAAU,IAAM,KAAA,EACtD,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,CAAA,kBAAA,EAAqB,EAAU,EAAC,oBAAA,EAAuB,AAAgB,KAAA,IAAhB,EAA4B,UAAY,EAAA,CAAa,EACrH,IAAM,EAAqB,MAAM,AAAA,CAAA,EAAA,EAAA,cAAA,AAAA,EAAe,EAAU,EAAE,CAAE,GAE9D,GAAI,CAAC,EAAoB,CAEvB,GADA,QAAQ,KAAK,CAAC,CAAA,kBAAA,EAAqB,EAAU,EAAC,sBAAA,CAAwB,EAClE,AAAY,IAAZ,EAA6B,OAAO,IACxC,OAAM,IAAI,QAAQ,AAAA,GAAW,WAAW,EAAS,MACjD,QACF,CAEA,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,CAAA,6CAAA,EAAgD,EAAU,EAAC,EAAA,CAAI,CAAE,GAE1E,IAAI,EAAY,gBACZ,EAAa,iBACb,EAAwB,KACxB,EAAc,GAEZ,EAAa,EAAmB,KAAK,CAAC,iBACxC,CAAA,GAAc,CAAU,CAAC,EAAE,EAAE,CAAA,EAAY,CAAU,CAAC,EAAE,CAAC,IAAI,EAA/D,EAEA,IAAM,EAAc,EAAmB,KAAK,CAAC,kBACzC,CAAA,GAAe,CAAW,CAAC,EAAE,EAAE,CAAA,EAAa,CAAW,CAAC,EAAE,CAAC,IAAI,EAAnE,EAEA,IAAM,EAAU,EAAmB,KAAK,CAAC,eACrC,CAAA,GAAW,CAAO,CAAC,EAAE,EAAE,CAAA,EAAS,SAAS,CAAO,CAAC,EAAE,CAAE,GAAzD,EAGI,AAAW,OAAX,GAAoB,EAAiB,QAAQ,CAAC,IAChD,EAAiB,IAAI,CAAC,GAGxB,IAAM,EAAgB,WAChB,EAAoB,EAAmB,OAAO,CAAC,GAErD,GAAI,AAAsB,KAAtB,EACF,EAAc,EAAmB,SAAS,CAAC,EAAoB,EAAc,MAAM,EAAE,IAAI,OACpF,CACL,IAAI,EAAoB,CACpB,CAAA,GAAY,CAAA,EAAoB,KAAK,GAAG,CAAC,EAAoB,AAAA,CAAA,EAAW,KAAK,EAAI,CAAA,EAAK,CAAU,CAAC,EAAE,CAAC,MAAM,CAAA,EAC1G,GAAa,CAAA,EAAoB,KAAK,GAAG,CAAC,EAAoB,AAAA,CAAA,EAAY,KAAK,EAAI,CAAA,EAAK,CAAW,CAAC,EAAE,CAAC,MAAM,CAAA,EAC7G,GAAS,CAAA,EAAoB,KAAK,GAAG,CAAC,EAAoB,AAAA,CAAA,EAAQ,KAAK,EAAI,CAAA,EAAK,CAAO,CAAC,EAAE,CAAC,MAAM,CAAA,EACjG,EAAoB,GAAK,EAAoB,EAAmB,MAAM,CACxE,EAAc,EAAmB,SAAS,CAAC,GAAmB,IAAI,GACxD,GAAe,GAAgB,IACzC,EAAc,EAAmB,IAAI,GACrC,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,wEAEb,CAEA,GAAI,CAAC,GAAe,EAAmB,WAAW,GAAG,QAAQ,CAAC,6BAA8B,CAExF,GADA,QAAQ,IAAI,CAAC,CAAA,QAAA,EAAW,EAAU,EAAC,mEAAA,CAAqE,EACpG,AAAY,IAAZ,EAA6B,OAAO,IACxC,OAAM,IAAI,QAAQ,AAAA,GAAW,WAAW,EAAS,MACjD,QACJ,CAEA,IAAI,EAAa,EACd,KAAK,CAAC,WACN,GAAG,CAAC,AAAC,GAAc,EAAE,IAAI,IACzB,MAAM,CAAC,AAAC,GAAc,EAAE,MAAM,CAAG,KAAO,CAAC,EAAE,UAAU,CAAC,sBAAwB,CAAC,EAAE,UAAU,CAAC,QAAU,CAAC,EAAE,QAAQ,CAAC,gBAAkB,CAAC,EAAE,UAAU,CAAC,YAAc,CAAC,EAAE,QAAQ,CAAC,sBAAwB,CAAC,QAAQ,IAAI,CAAC,IAClN,KAAK,CAAC,EAAG,IAyBZ,GAvBI,EAAW,MAAM,CAAG,IACtB,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,CAAA,QAAA,EAAW,EAAU,EAAC,mEAAA,CAAqE,EACpG,EAAa,EACV,OAAO,CAAC,QAAS,MACjB,KAAK,CAAC,iBACN,GAAG,CAAC,AAAC,GAAc,EAAE,OAAO,CAAC,MAAO,KAAK,IAAI,IAC7C,MAAM,CAAC,AAAC,GAAc,EAAE,MAAM,CAAG,KAAO,CAAC,EAAE,QAAQ,CAAC,sBACpD,KAAK,CAAC,EAAG,KAGd,EAAW,IAAI,CAAC,CAAC,EAAG,KAClB,IAAM,EAAS,KAAK,GAAG,CAAC,EAAE,MAAM,CAAE,KAAQ,KAAK,GAAG,CAAC,EAAG,IAAO,EAAE,MAAM,EAAK,AAAyB,MAAzB,EAAE,KAAK,CAAC,eAElF,OAAO,AADQ,KAAK,GAAG,CAAC,EAAE,MAAM,CAAE,KAAQ,KAAK,GAAG,CAAC,EAAG,IAAO,EAAE,MAAM,EAAK,AAAyB,MAAzB,EAAE,KAAK,CAAC,eAClE,CAClB,GAEA,EAAa,EAAW,KAAK,CAAC,EAAG,GAE7B,AAAsB,IAAtB,EAAW,MAAM,EACnB,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,CAAA,QAAA,EAAW,EAAU,EAAC,mEAAA,CAAqE,EAIlG,EAAW,MAAM,CAAG,EAEtB,OADA,QAAQ,GAAG,CAAC,CAAA,QAAA,EAAW,EAAU,EAAC,yBAAA,EAA4B,EAAW,MAAM,CAAA,YAAA,CAAc,EACtF,CACL,WAAY,EACZ,SAAU,CACR,MAAO,EACP,OAAQ,EACR,GAAI,AAAW,OAAX,EAAkB,EAAS,CAChC,CACF,EAED,QAAQ,IAAI,CAAC,CAAA,QAAA,EAAW,EAAU,EAAC,qBAAA,EAAwB,EAAW,MAAM,CAAA,kDAAA,CAAoD,CAIpI,CAAE,MAAO,EAAO,CACd,QAAQ,KAAK,CAAC,CAAA,wDAAA,EAA2D,EAAU,EAAC,EAAA,CAAI,CAAE,EAE5F,CACI,EAAU,GACZ,MAAM,IAAI,QAAQ,AAAA,GAAW,WAAW,EAAS,IAAQ,CAAA,EAAU,CAAA,GAEvE,CAGA,OADA,QAAQ,KAAK,CAAC,yDACP,IACT,CAuBA,SAAS,EAAqC,CAAgB,CAAE,EAAgC,QAAQ,EACpG,IAAM,EAAU,EAAU,aAAa,CAAC,UACxC,AAAK,IACD,QAAQ,IAAI,CAAC,CAAA,uBAAA,EAA0B,EAAQ,YAAA,CAAc,EACtD,KAGf,CAuCsB,aAAlB,OAAO,SACN,OAAe,UAAU,CAAG,EAAA,UAAA,CAE7B,QAAQ,GAAG,CAAC,4CAIhB,SAAS,gBAAgB,CAAC,mBAAoB,KA3C1C,GAAI,CACA,EAAoB,EAA+B,wBAA0B,SAAS,aAAa,CAAC,OACpG,EAAW,EAA+B,eAAiB,SAAS,aAAa,CAAC,OAClF,EAAa,EAA+B,YAAc,SAAS,aAAa,CAAC,OACjF,EAAU,EAAqC,cAAgB,SAAS,aAAa,CAAC,UACtF,EAAY,EAAqC,gBAAkB,SAAS,aAAa,CAAC,UAC1F,EAAY,EAA+B,gBAAkB,SAAS,aAAa,CAAC,OAGpF,EAAa,EAAqC,kBAAoB,SAAS,aAAa,CAAC,UAG5E,EAA+B,qBAAuB,SAAS,aAAa,CAAC,OAC/E,EAAqC,oBAAsB,SAAS,aAAa,CAAC,UAEjG,QAAQ,GAAG,CAAC,oCAAqC,CAC7C,cAAe,CAAC,CAAC,SAAS,aAAa,CAAC,cACxC,oBAAqB,CAAC,CAAC,SAAS,aAAa,CAAC,oBAC9C,kBAAmB,CAAC,CAAC,SAAS,aAAa,CAAC,kBAC/C,GAGD,AAAA,CAAA,EAAA,EAAA,yBAAA,AAAA,EAA0B,CACtB,SAAA,EACA,UAAA,EACA,UAAA,EACA,QAAA,EACA,WAAA,EACA,kBAAA,CACH,EACL,CAAE,MAAO,EAAO,CACZ,QAAQ,KAAK,CAAC,8BAA+B,EACjD,CAmBA,EAAW,gBAAgB,CAAC,QAAS,UAEnC,MAAM,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAoB,CAAA,EAC5B,GACA,EAAU,gBAAgB,CAAC,QAAS,IAAM,AAAA,CAAA,EAAA,EAAA,gBAAA,AAAA,IAS9C,E,G,E,Q,S,C,C,C,E,E,E,O,C,iB,I,G,I,E,E,S,E,E,SCxVO,IAAM,EAA+D,CAE3E,EAGD,SAAS,EAAY,CAAe,CAAE,CAAS,EAE7C,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,CAAA,wBAAA,EAA2B,EAAA,CAAS,CAAE,EACjD,CASO,eAAe,EAAQ,CAA6B,CAAE,CAA+B,CAAE,CAAoB,EAChH,IAAM,EAMF,CACF,MAAO,iCACP,SAAA,CAID,CAEmB,MAAA,IAAhB,IACF,EAAK,WAAW,CAAG,EACnB,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,wCAAyC,IAIhD,GAAgB,EAAa,MAAM,CAAG,GACxC,EAAK,KAAK,CAAG,EACb,EAAK,WAAW,CAAG,OACnB,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,2BAA4B,IAKrC,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,4FAGX,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,sCAAuC,GAEhD,GAAI,CACF,IAAM,EAAS,AAAA,CAAA,EAAA,EAAA,oBAAA,AAAA,IAAuB,kBAAkB,CAElD,EAAW,MAAM,MACrB,gDACA,CACE,OAAQ,OACR,QAAS,CACP,cAAe,CAAA,OAAA,EAAU,EAAA,CAAQ,CACjC,eAAgB,mBAChB,eAAgB,AAAkB,aAAlB,OAAO,OAAyB,OAAO,QAAQ,CAAC,IAAI,CAAG,GACvE,UAAW,OACZ,EACD,KAAM,KAAK,SAAS,CAAC,EACtB,GAGH,GAAI,CAAC,EAAS,EAAE,CAAE,KACZ,EACJ,GAAI,CACF,EAAY,MAAM,EAAS,IAAI,EACjC,CAAE,MAAO,EAAG,CACV,EAAY,MAAM,EAAS,IAAI,EACjC,CACA,IAAM,EAAe,AAAsB,UAAtB,OAAQ,GAA0B,GAAW,OAAO,QAAW,EAAU,KAAK,CAAC,OAAO,CAAI,AAAqB,UAArB,OAAO,EAAyB,EAAY,mBAE3J,OADA,QAAQ,KAAK,CAAC,qCAAsC,EAAS,MAAM,CAAE,GAC/D,AAAI,MAAM,CAAA,sBAAA,EAAyB,EAAS,MAAM,CAAA,GAAA,EAAM,EAAA,CAAc,CAC9E,CAEA,IAAM,EAAO,MAAM,EAAS,IAAI,GAGhC,GAFA,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,uCAAwC,GAE7C,CAAC,EAAK,OAAO,EAAI,CAAC,EAAK,OAAO,CAAC,EAAE,EAAI,CAAC,EAAK,OAAO,CAAC,EAAE,CAAC,OAAO,CAE/D,MADA,QAAQ,KAAK,CAAC,2DAA4D,GACpE,AAAI,MAAM,+CAElB,OAAO,EAAK,OAAO,CAAC,EAAE,CAAC,OAA4B,AACrD,CAAE,MAAO,EAAO,CAEd,MADA,QAAQ,KAAK,CAAC,6CAA8C,GACtD,CACR,CACF,CAOO,eAAe,EAAgB,CAAoC,MASpE,EARJ,GAAI,CAAC,EAAkB,UAAU,EAAI,AAAwC,IAAxC,EAAkB,UAAU,CAAC,MAAM,CACtE,MAAM,AAAI,MAAM,mDAGlB,IAAM,EAAW,EAAkB,UAAU,CAAC,EAAE,CAC1C,EAAW,EAAS,QAAQ,CAAC,IAAI,CACvC,EAAY,qBAAsB,CAAE,SAAA,EAAU,WAAY,EAAS,EAAE,AAAA,GAGrE,GAAI,CACF,EAAW,KAAK,KAAK,CAAC,EAAS,QAAQ,CAAC,SAAS,EACjD,EAAY,wBAAyB,EACvC,CAAE,MAAO,EAAO,CAGd,OADA,QAAQ,KAAK,CAAC,+CADG,GAEV,CACL,KAAM,OACN,aAAc,EAAS,EAAE,CACzB,KAAM,EACN,QAAS,KAAK,SAAS,CAAC,CAAE,MAAO,CAAA,gCAAA,EAAmC,AANrD,EAM8D,OAAO,CAAA,CAAE,AAAA,EACvF,CACH,CAEA,IAAM,EAAe,CAAY,CAAC,EAAS,CAC3C,GAAI,CAAC,EAEH,OADA,QAAQ,KAAK,CAAC,CAAA,kBAAA,EAAqB,EAAQ,2BAAA,CAA6B,EACjE,CACL,KAAM,OACN,aAAc,EAAS,EAAE,CACzB,KAAM,EACN,QAAS,KAAK,SAAS,CAAC,CAAE,MAAO,CAAA,KAAA,EAAQ,EAAQ,WAAA,CAAa,AAAA,EAC/D,EAGH,GAAI,CACF,EAAY,0BAA2B,CAAE,KAAM,CAAQ,GACvD,IAAM,EAAa,MAAM,EAAa,GAEtC,OADA,EAAY,wBAAyB,GAC9B,CACL,KAAM,OACN,aAAc,EAAS,EAAE,CACzB,KAAM,EACN,QAAS,KAAK,SAAS,CAAC,EACzB,CACH,CAAE,MAAO,EAAY,CAEnB,OADA,QAAQ,KAAK,CAAC,CAAA,kCAAA,EAAqC,EAAQ,CAAA,CAAG,CAAE,GACzD,CACL,KAAM,OACN,aAAc,EAAS,EAAE,CACzB,KAAM,EACN,QAAS,KAAK,SAAS,CAAC,CAAE,MAAO,CAAA,qBAAA,EAAwB,EAAQ,EAAA,EAAK,EAAM,OAAO,CAAA,CAAE,AAAA,EACtF,CACH,CACF,CASO,eAAe,EAAe,CAAoC,CAAE,CAA2B,CAAE,CAAoB,EAC1H,IAAI,EAAgC,IAAI,EAAgB,CAGxD,IAAK,IAAI,EAAI,EAAG,EAFO,EAEa,IAAK,CACvC,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,CAAA,oCAAA,EAAuC,EAAI,EAAA,CAAG,EACvD,IAAM,EAAoB,MAAM,EAAQ,EAAU,EAAW,GAG7D,GAFA,EAAS,IAAI,CAAC,GAEV,CAAA,EAAkB,UAAU,GAAI,CAAA,EAAkB,UAAU,CAAC,MAAM,CAAG,CAAA,EAMxE,OAAO,EAAkB,OAAO,EAAI,IANuC,EAE3E,IAAM,EAAsB,MAAM,EAAgB,GAClD,EAAS,IAAI,CAAC,EAChB,CAIF,CAEA,QAAQ,IAAI,CAAC,qDACb,IAAM,EAAc,EAAS,MAAM,CAAG,EAAI,CAAQ,CAAC,EAAS,MAAM,CAAG,EAAE,CAAG,YAC1E,AAAI,GAAe,AAAqB,cAArB,EAAY,IAAI,EAAoB,EAAY,OAAO,CACjE,EAAY,OAAO,CAErB,gFACT,C,G,E","sources":["<anon>","src/utils/environmentConfig.ts","src/utils/debugLog.ts","src/services/gameLogic.ts","src/main.ts","src/services/llmService.ts"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequired201\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequired201\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"6nwBV\", function(module, exports) {\n\n$parcel$export(module.exports, \"getEnvironmentConfig\", () => $4a4e2fe1326f8d10$export$5911d6599ccd5587);\n$parcel$export(module.exports, \"isUsingUserProvidedApiKey\", () => $4a4e2fe1326f8d10$export$743c700ce157bd09);\n$parcel$export(module.exports, \"setUserApiKey\", () => $4a4e2fe1326f8d10$export$2efac152e5544c6f);\n// src/utils/environmentConfig.ts\n\nvar $gAFfX = parcelRequire(\"gAFfX\");\n/**\n * Environment configuration management for the application\n * Handles secure storage and retrieval of sensitive configuration values\n */ // Define the default safe fallback key (will be used if no key is found)\n// This key is obfuscated to prevent direct copying\nconst $4a4e2fe1326f8d10$var$ENCODED_DEFAULT_KEY = 'c2stb3ItdjEtNGY4MmQ3NDBlZmQyNjlhY2IwYTA4MGIzMTgyNTQ5NDlhMTQ5Y2FlYTZmNzFkODAxMGM0MDJkNWQ5ZGViYjQ1Zg==';\nfunction $4a4e2fe1326f8d10$export$9b37f4151ec193f8() {\n    return window.location.hostname.includes('github.io') || window.location.hostname === 'cloze-reader.vercel.app' || window.location.protocol === 'file:';\n}\nfunction $4a4e2fe1326f8d10$export$5911d6599ccd5587() {\n    const remote = $4a4e2fe1326f8d10$export$9b37f4151ec193f8();\n    // Try to get user-set API key from localStorage\n    const userProvidedKey = localStorage.getItem('openrouter_api_key');\n    const isUserKeyValid = Boolean(userProvidedKey) && userProvidedKey.startsWith('sk-or-') && userProvidedKey.length > 20;\n    // Decode the default key\n    const defaultKey = atob($4a4e2fe1326f8d10$var$ENCODED_DEFAULT_KEY);\n    // Use default key if in remote interface, otherwise use user key if valid\n    const apiKey = remote ? defaultKey : isUserKeyValid ? userProvidedKey : defaultKey;\n    (0, $gAFfX.debugLog)(\"Environment config loaded\", {\n        isRemoteInterface: remote,\n        usingUserKey: !remote && isUserKeyValid,\n        keyFormat: apiKey.substring(0, 8) + \"...\"\n    });\n    return {\n        OPENROUTER_API_KEY: apiKey,\n        IS_REMOTE_INTERFACE: remote\n    };\n}\nfunction $4a4e2fe1326f8d10$export$743c700ce157bd09() {\n    // In remote interfaces, always report as using the default key\n    if ($4a4e2fe1326f8d10$export$9b37f4151ec193f8()) return false;\n    const userProvidedKey = localStorage.getItem('openrouter_api_key');\n    return Boolean(userProvidedKey) && userProvidedKey.startsWith('sk-or-') && userProvidedKey.length > 20;\n}\nfunction $4a4e2fe1326f8d10$export$2efac152e5544c6f(key) {\n    // In remote interfaces, don't allow setting custom API keys\n    if ($4a4e2fe1326f8d10$export$9b37f4151ec193f8()) {\n        (0, $gAFfX.debugLog)(\"Cannot set custom API key in remote interface\");\n        return false;\n    }\n    const trimmedKey = key.trim();\n    if (trimmedKey && trimmedKey.startsWith('sk-or-') && trimmedKey.length > 20) {\n        localStorage.setItem('openrouter_api_key', trimmedKey);\n        return true;\n    }\n    return false;\n}\n\n});\nparcelRegister(\"gAFfX\", function(module, exports) {\n\n$parcel$export(module.exports, \"debugLog\", () => $c14002d12a315116$export$140d7860bc6d1e6e);\n// src/utils/debugLog.ts\n/**\n * Helper function to add detailed debug logs to the console.\n * Includes a timestamp and optional data payload.\n * @param message The main log message.\n * @param data Optional data to be logged as a JSON string.\n */ function $c14002d12a315116$export$140d7860bc6d1e6e(message, data) {\n    const timestamp = new Date().toISOString();\n    console.log(`[DEBUG ${timestamp}] ${message}`);\n    if (data !== undefined) try {\n        // Attempt to stringify, handling potential circular references or large objects\n        const jsonData = JSON.stringify(data, (key, value)=>{\n            if (value instanceof HTMLElement) return `HTMLElement (${value.tagName}${value.id ? '#' + value.id : ''})`;\n            // Add more complex object handling here if needed\n            return value;\n        }, 2);\n        console.log(jsonData);\n    } catch (error) {\n        console.log('[DEBUG Data Stringify Error]', error);\n        console.log('[DEBUG Raw Data]', data); // Log raw data if stringify fails\n    }\n}\n\n});\n\n\nparcelRegister(\"59ye1\", function(module, exports) {\n\n$parcel$export(module.exports, \"initializeGameDOMElements\", () => $3c0857659fbe7bcd$export$9d09d44d755232c3);\n$parcel$export(module.exports, \"resetGame\", () => $3c0857659fbe7bcd$export$8a9e2a13fbf8faaf);\n$parcel$export(module.exports, \"startRound\", () => $3c0857659fbe7bcd$export$b5f85e4b788b2112);\n$parcel$export(module.exports, \"handleSubmission\", () => $3c0857659fbe7bcd$export$f4978f2673be205b);\n// src/services/gameLogic.ts\n\nvar $gAFfX = parcelRequire(\"gAFfX\");\n\nvar $64gHy = parcelRequire(\"64gHy\");\n// --- Caching ---\nconst $3c0857659fbe7bcd$var$paragraphCache = {\n    cache: {},\n    maxSize: 10,\n    set: function(key, value) {\n        if (Object.keys(this.cache).length >= this.maxSize) {\n            const oldestKey = Object.keys(this.cache)[0];\n            delete this.cache[oldestKey];\n        }\n        this.cache[key] = {\n            value: value,\n            timestamp: Date.now()\n        };\n        try {\n            localStorage.setItem('paragraphCache', JSON.stringify(this.cache));\n        } catch (e) {\n            console.warn('Could not save cache to localStorage', e);\n        }\n    },\n    get: function(key) {\n        const item = this.cache[key];\n        if (!item) return null;\n        if (Date.now() - item.timestamp > 86400000) {\n            delete this.cache[key];\n            try {\n                localStorage.setItem('paragraphCache', JSON.stringify(this.cache));\n            } catch (e) {\n                console.warn('Could not update cache in localStorage', e);\n            }\n            return null;\n        }\n        return item.value;\n    },\n    init: function() {\n        try {\n            const saved = localStorage.getItem('paragraphCache');\n            if (saved) this.cache = JSON.parse(saved);\n        } catch (e) {\n            console.warn('Could not load cache from localStorage', e);\n            this.cache = {};\n        }\n    }\n};\n// Initialize the cache when the module is loaded\n$3c0857659fbe7bcd$var$paragraphCache.init();\nfunction $3c0857659fbe7bcd$export$a49bff6fbcf3a3c9(words, count) {\n    const indices = [];\n    if (words.length === 0 || count === 0) return indices;\n    const functionWords = new Set([\n        'the',\n        'a',\n        'an',\n        'and',\n        'or',\n        'but',\n        'if',\n        'of',\n        'at',\n        'by',\n        'for',\n        'with',\n        'about',\n        'to',\n        'from',\n        'in',\n        'on',\n        'is',\n        'are',\n        'was',\n        'were',\n        'be',\n        'been',\n        'being',\n        'have',\n        'has',\n        'had',\n        'do',\n        'does',\n        'did',\n        'will',\n        'would',\n        'shall',\n        'should',\n        'can',\n        'could',\n        'may',\n        'might',\n        'must',\n        'that',\n        'which',\n        'who',\n        'whom',\n        'whose',\n        'this',\n        'these',\n        'those',\n        'am',\n        'i',\n        'we',\n        'you',\n        'he',\n        'she',\n        'they',\n        'we',\n        'it' // Corrected: removed duplicate 'we'\n    ]);\n    const scoredWords = words.map((word, index)=>{\n        const cleanWord = word.toLowerCase().replace(/[^\\w]/g, '');\n        let score = 0;\n        score += cleanWord.length * 2;\n        if (functionWords.has(cleanWord)) score -= 10;\n        if (index > 0 && word[0] === word[0].toUpperCase() && word[0].match(/[A-Z]/)) score += 5;\n        score += Math.random() * 2;\n        return {\n            index: index,\n            score: score\n        };\n    });\n    scoredWords.sort((a, b)=>b.score - a.score);\n    const actualCount = Math.min(count, words.length);\n    const candidatePoolSize = Math.min(actualCount * 2, words.length);\n    const topCandidates = scoredWords.slice(0, candidatePoolSize);\n    while(indices.length < actualCount && topCandidates.length > 0){\n        const randomIndex = Math.floor(Math.random() * topCandidates.length);\n        const selectedWord = topCandidates.splice(randomIndex, 1)[0];\n        indices.push(selectedWord.index);\n    }\n    return indices.sort((a, b)=>a - b);\n}\nfunction $3c0857659fbe7bcd$export$23836e216f399b60(words, count = 3) {\n    const commonWords = new Set([\n        'the',\n        'and',\n        'of',\n        'to',\n        'a',\n        'in',\n        'that',\n        'it',\n        'is',\n        'was',\n        'were',\n        'for',\n        'on',\n        'with',\n        'as',\n        'by',\n        'an',\n        'be',\n        'at',\n        'or',\n        'i',\n        'he',\n        'she',\n        'they',\n        'we',\n        'you',\n        'my',\n        'his',\n        'her',\n        'its',\n        'our',\n        'your',\n        'them',\n        'us',\n        'me',\n        'had',\n        'has',\n        'have',\n        'do',\n        'does',\n        'did',\n        'will',\n        'would',\n        'should',\n        'can',\n        'could',\n        'may',\n        'might',\n        'must',\n        'not',\n        'no',\n        'so',\n        'if',\n        'but',\n        'very',\n        'just',\n        'from',\n        'into',\n        'out',\n        'up',\n        'down',\n        'over',\n        'under',\n        'again',\n        'then',\n        'once',\n        'here',\n        'there',\n        'when',\n        'where',\n        'why',\n        'how',\n        'all',\n        'any',\n        'both',\n        'each',\n        'few',\n        'more',\n        'most',\n        'other',\n        'some',\n        'such',\n        'than',\n        'too',\n        'very',\n        's',\n        't',\n        'd',\n        'll',\n        'm',\n        'o',\n        're',\n        've'\n    ]);\n    const frequency = {};\n    words.forEach((word)=>{\n        const cleanWord = word.toLowerCase().replace(/[^a-z0-9']/g, '');\n        if (cleanWord.length > 3 && !commonWords.has(cleanWord) && !/^\\d+$/.test(cleanWord)) frequency[cleanWord] = (frequency[cleanWord] || 0) + 1;\n    });\n    return Object.entries(frequency).sort(([, a], [, b])=>b - a).slice(0, count).map(([term])=>term);\n}\nlet $3c0857659fbe7bcd$export$7270d0e0b4d16214 = [\n    [],\n    []\n];\nlet $3c0857659fbe7bcd$export$8d792ae58277cf50 = [\n    [],\n    []\n];\nlet $3c0857659fbe7bcd$export$2077e0241d6afd3c = 1;\nlet $3c0857659fbe7bcd$export$f69a3a7a70d5284b = 1;\nlet $3c0857659fbe7bcd$export$a6ae94fc66d9d8b3 = 5;\nlet $3c0857659fbe7bcd$export$71a5d0721a141a3f = new Set();\nlet $3c0857659fbe7bcd$export$8ea65ab2a8063b73 = [];\nlet $3c0857659fbe7bcd$var$domElements = null;\nfunction $3c0857659fbe7bcd$export$9d09d44d755232c3(elements) {\n    $3c0857659fbe7bcd$var$domElements = elements;\n}\nfunction $3c0857659fbe7bcd$export$f9a124f5758d48a2() {\n    if (!$3c0857659fbe7bcd$var$domElements) {\n        console.error(\"DOM elements not initialized for gameLogic.renderRound\");\n        return;\n    }\n    const { gameArea: gameArea, roundInfo: roundInfo, submitBtn: submitBtn, hintBtn: hintBtn, resultArea: resultArea } = $3c0857659fbe7bcd$var$domElements;\n    const totalBlanks = $3c0857659fbe7bcd$export$8d792ae58277cf50[0].length + $3c0857659fbe7bcd$export$8d792ae58277cf50[1].length;\n    roundInfo.textContent = `Round ${$3c0857659fbe7bcd$export$2077e0241d6afd3c} \\u{2014} ${totalBlanks} blanks`;\n    gameArea.innerHTML = '';\n    if ($3c0857659fbe7bcd$export$7270d0e0b4d16214[0].length === 0 && $3c0857659fbe7bcd$export$7270d0e0b4d16214[1].length === 0) {\n        gameArea.innerHTML = '<p class=\"text-red-500\">Error: No paragraphs loaded.</p>';\n        submitBtn.disabled = true;\n        hintBtn.disabled = true;\n        // stopTimer(); // stopTimer is not directly called here but good to note dependency\n        return;\n    }\n    for(let pIdx = 0; pIdx < 2; pIdx++){\n        if ($3c0857659fbe7bcd$export$7270d0e0b4d16214[pIdx].length === 0) continue;\n        const paragraphElement = document.createElement('p');\n        paragraphElement.className = 'typewriter-text leading-relaxed break-words mb-6';\n        paragraphElement.style.maxWidth = '100%';\n        paragraphElement.style.overflowWrap = 'break-word';\n        gameArea.appendChild(paragraphElement);\n        $3c0857659fbe7bcd$export$7270d0e0b4d16214[pIdx].forEach((word, idx)=>{\n            if ($3c0857659fbe7bcd$export$8d792ae58277cf50[pIdx].includes(idx)) {\n                const input = document.createElement('input');\n                input.type = 'text';\n                input.dataset.index = String(idx);\n                input.dataset.paragraph = String(pIdx);\n                input.placeholder = '_____';\n                // Enhanced styling for input boxes\n                input.className = 'border-b-2 border-typewriter-ink w-24 mx-1 text-center bg-transparent focus:outline-none focus:border-typewriter-ribbon focus:ring-1 focus:ring-typewriter-ribbon rounded-sm px-1 py-0.5 text-typewriter-ink placeholder-typewriter-ink placeholder-opacity-50';\n                input.addEventListener('keydown', (e)=>{\n                    if (e.key.length === 1) {\n                        input.classList.add('shadow-typewriter-pressed');\n                        setTimeout(()=>input.classList.remove('shadow-typewriter-pressed'), 100);\n                    }\n                });\n                input.addEventListener('input', ()=>{\n                    const allFilled = Array.from(gameArea.querySelectorAll('input[type=\"text\"]')).every((i)=>i.value.trim() !== '');\n                    submitBtn.disabled = !allFilled;\n                });\n                paragraphElement.appendChild(input);\n                paragraphElement.appendChild(document.createTextNode(' '));\n                input.addEventListener('focus', ()=>{\n                    if (!$3c0857659fbe7bcd$var$domElements) return; // Guard against null domElements\n                    const paragraphIdx = Number(input.dataset.paragraph);\n                    const wordIdx = Number(input.dataset.index);\n                    const blankKey = `${paragraphIdx}-${wordIdx}`;\n                    $3c0857659fbe7bcd$var$domElements.hintBtn.disabled = $3c0857659fbe7bcd$export$a6ae94fc66d9d8b3 <= 0 || $3c0857659fbe7bcd$export$71a5d0721a141a3f.has(blankKey);\n                    $3c0857659fbe7bcd$var$domElements.hintBtn.onclick = ()=>{\n                        if ($3c0857659fbe7bcd$export$a6ae94fc66d9d8b3 > 0 && !$3c0857659fbe7bcd$export$71a5d0721a141a3f.has(blankKey)) {\n                            const originalWord = $3c0857659fbe7bcd$export$7270d0e0b4d16214[paragraphIdx][wordIdx];\n                            if (originalWord) {\n                                const hintText = `Starts with \"${originalWord[0]}\", length ${originalWord.length}.`;\n                                const hintDiv = document.createElement('div');\n                                hintDiv.className = 'fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50';\n                                hintDiv.innerHTML = `\n                  <div class=\"bg-aged-paper p-6 rounded shadow-typewriter max-w-md text-center typewriter-text\">\n                    <h3 class=\"text-xl font-bold mb-4 text-shadow-typewriter\">Hint</h3>\n                    <p>${hintText}</p>\n                    <button class=\"mt-4 px-4 py-2 typewriter-key hover:bg-aged-paper\">Got it</button>\n                  </div>\n                `;\n                                document.body.appendChild(hintDiv);\n                                const closeHint = ()=>document.body.removeChild(hintDiv);\n                                hintDiv.querySelector('button')?.addEventListener('click', closeHint);\n                                hintDiv.addEventListener('click', (e)=>{\n                                    if (e.target === hintDiv) closeHint();\n                                });\n                                $3c0857659fbe7bcd$export$a6ae94fc66d9d8b3--;\n                                if ($3c0857659fbe7bcd$var$domElements) $3c0857659fbe7bcd$var$domElements.hintBtn.textContent = `Hint (${$3c0857659fbe7bcd$export$a6ae94fc66d9d8b3})`;\n                                $3c0857659fbe7bcd$export$71a5d0721a141a3f.add(blankKey);\n                                input.classList.add('hinted-blank');\n                                if ($3c0857659fbe7bcd$var$domElements) $3c0857659fbe7bcd$var$domElements.hintBtn.disabled = $3c0857659fbe7bcd$export$a6ae94fc66d9d8b3 <= 0 || $3c0857659fbe7bcd$export$71a5d0721a141a3f.has(blankKey);\n                            }\n                        }\n                    };\n                });\n            } else {\n                const wordSpan = document.createElement('span');\n                wordSpan.textContent = word + ' ';\n                wordSpan.className = 'typewriter-text';\n                paragraphElement.appendChild(wordSpan);\n            }\n        });\n    }\n    const totalRedactedCount = $3c0857659fbe7bcd$export$8d792ae58277cf50[0].length + $3c0857659fbe7bcd$export$8d792ae58277cf50[1].length;\n    submitBtn.disabled = totalRedactedCount === 0;\n    hintBtn.disabled = $3c0857659fbe7bcd$export$a6ae94fc66d9d8b3 <= 0 || totalRedactedCount === 0;\n    resultArea.textContent = '';\n    // Assuming startTimer is globally available or will be handled\n    if (typeof startTimer === 'function') startTimer();\n    setTimeout(()=>{\n        if (typeof window !== 'undefined' && window.applyTypewriterEffect) window.applyTypewriterEffect();\n    }, 100);\n}\nfunction $3c0857659fbe7bcd$export$8a9e2a13fbf8faaf() {\n    if (!$3c0857659fbe7bcd$var$domElements) {\n        console.error(\"DOM elements not initialized for gameLogic.resetGame\");\n        return;\n    }\n    const { gameArea: gameArea, resultArea: resultArea, roundInfo: roundInfo, bibliographicArea: bibliographicArea } = $3c0857659fbe7bcd$var$domElements;\n    $3c0857659fbe7bcd$export$2077e0241d6afd3c = 1;\n    $3c0857659fbe7bcd$export$f69a3a7a70d5284b = 1;\n    $3c0857659fbe7bcd$export$a6ae94fc66d9d8b3 = 5;\n    $3c0857659fbe7bcd$export$71a5d0721a141a3f.clear();\n    $3c0857659fbe7bcd$export$7270d0e0b4d16214[0] = [];\n    $3c0857659fbe7bcd$export$7270d0e0b4d16214[1] = [];\n    $3c0857659fbe7bcd$export$8d792ae58277cf50[0] = [];\n    $3c0857659fbe7bcd$export$8d792ae58277cf50[1] = [];\n    $3c0857659fbe7bcd$export$8ea65ab2a8063b73 = []; // Reset previous books on a full game reset\n    if (gameArea) gameArea.innerHTML = '';\n    if (resultArea) resultArea.textContent = '';\n    if (roundInfo) roundInfo.textContent = '';\n    if (bibliographicArea) bibliographicArea.innerHTML = '';\n    if (typeof stopTimer === 'function') stopTimer();\n    (0, $gAFfX.debugLog)(\"Game reset in gameLogic.ts\");\n}\nasync function $3c0857659fbe7bcd$export$b5f85e4b788b2112(forceNewPassage = false) {\n    if (!$3c0857659fbe7bcd$var$domElements) {\n        console.error(\"DOM elements not initialized for gameLogic.startRound\");\n        return;\n    }\n    const { gameArea: gameArea, roundInfo: roundInfo, submitBtn: submitBtn, hintBtn: hintBtn, resultArea: resultArea, bibliographicArea: bibliographicArea } = $3c0857659fbe7bcd$var$domElements;\n    $3c0857659fbe7bcd$export$a6ae94fc66d9d8b3 = 3;\n    if (hintBtn) hintBtn.textContent = `Hint (${$3c0857659fbe7bcd$export$a6ae94fc66d9d8b3})`;\n    if (submitBtn) submitBtn.disabled = true;\n    if (hintBtn) hintBtn.disabled = true;\n    if (gameArea) gameArea.innerHTML = '<div class=\"text-center p-4\"><p class=\"text-lg typewriter-text\">Fetching new paragraphs from Gutenberg...</p><p class=\"text-sm mt-2 text-opacity-70\">*click* *clack* *ding*</p></div>';\n    if (resultArea) resultArea.textContent = '';\n    $3c0857659fbe7bcd$export$71a5d0721a141a3f.clear();\n    if (typeof stopTimer === 'function') stopTimer();\n    if (bibliographicArea) bibliographicArea.innerHTML = '';\n    const category = localStorage.getItem('game_category') || '';\n    const author = localStorage.getItem('game_author') || '';\n    const century = localStorage.getItem('game_century') || ''; // Fetch century as well\n    let cacheKey = `passage_${category || 'any'}_${author || 'any'}_${century || 'any'}`; // Include century in cache key\n    // If all search parameters are empty, it's a \"random\" request.\n    // Add a random component to the cache key to ensure a fresh fetch for \"truly random\" initial passages,\n    // unless forceNewPassage is explicitly false (which might be used for specific reloads of the *same* random passage).\n    // However, startRound is usually called with forceNewPassage=true for the very first load via app.tsx.\n    if (!category && !author && !century && forceNewPassage) {\n        cacheKey = `passage_random_${Date.now()}_${Math.random().toString(36).substring(7)}`;\n        (0, $gAFfX.debugLog)(\"Generated unique cache key for initial random passage:\", {\n            cacheKey: cacheKey\n        });\n    }\n    const cachedPassage = $3c0857659fbe7bcd$var$paragraphCache.get(cacheKey);\n    // For truly random initial fetches, we want to bypass cache even if forceNewPassage wasn't explicitly true,\n    // but the logic above already makes the cacheKey unique, effectively bypassing it.\n    if (!forceNewPassage && cachedPassage && !cacheKey.startsWith('passage_random_')) {\n        (0, $gAFfX.debugLog)(\"Serving passage from cache\", {\n            cacheKey: cacheKey\n        });\n        const parsedCache = JSON.parse(cachedPassage);\n        if (parsedCache && parsedCache.paragraphs && Array.isArray(parsedCache.paragraphs)) {\n            const passageData = {\n                paragraphs: parsedCache.paragraphs,\n                metadata: parsedCache.metadata || null\n            };\n            if (bibliographicArea && passageData.metadata) {\n                // Add to previous books history if not already there\n                const isAlreadyFetched = $3c0857659fbe7bcd$export$8ea65ab2a8063b73.some((book)=>book.id === passageData.metadata.id);\n                if (!isAlreadyFetched) {\n                    $3c0857659fbe7bcd$export$8ea65ab2a8063b73.unshift(passageData.metadata);\n                    if ($3c0857659fbe7bcd$export$8ea65ab2a8063b73.length > 5) $3c0857659fbe7bcd$export$8ea65ab2a8063b73.pop();\n                }\n                let historyHtml = '';\n                if ($3c0857659fbe7bcd$export$8ea65ab2a8063b73.length > 1) {\n                    historyHtml = '<p class=\"text-xs text-typewriter-ink opacity-60 mt-1\">Previously fetched:</p><ul class=\"text-xs list-disc list-inside opacity-60\">';\n                    $3c0857659fbe7bcd$export$8ea65ab2a8063b73.slice(1, 5).forEach((book)=>{\n                        historyHtml += `<li><a href=\"https://www.gutenberg.org/ebooks/${book.id}\" target=\"_blank\" class=\"underline hover:text-typewriter-ribbon\">${book.title} by ${book.author}</a></li>`;\n                    });\n                    historyHtml += '</ul>';\n                }\n                bibliographicArea.innerHTML = `\n                <p class=\"text-sm text-typewriter-ink opacity-80 mb-1\">\n                    (Cached) Currently from: <em><a href=\"https://www.gutenberg.org/ebooks/${passageData.metadata.id}\" target=\"_blank\" class=\"underline hover:text-typewriter-ribbon\">${passageData.metadata.title}</a></em> by ${passageData.metadata.author} (ID: ${passageData.metadata.id})\n                </p>\n                ${historyHtml}\n            `;\n                setTimeout(()=>{\n                    if (typeof window !== 'undefined' && window.applyTypewriterEffect) {\n                        const metaElements = bibliographicArea.querySelectorAll('p, em, a, li');\n                        metaElements.forEach((el)=>window.applyTypewriterEffect(el));\n                    }\n                }, 100);\n            }\n            $3c0857659fbe7bcd$export$7270d0e0b4d16214[0] = passageData.paragraphs[0].split(/\\s+/).filter((w)=>w.length > 0);\n            $3c0857659fbe7bcd$export$7270d0e0b4d16214[1] = passageData.paragraphs.length > 1 ? passageData.paragraphs[1].split(/\\s+/).filter((w)=>w.length > 0) : [];\n            $3c0857659fbe7bcd$export$8d792ae58277cf50[0].length = 0;\n            $3c0857659fbe7bcd$export$8d792ae58277cf50[1].length = 0;\n            const totalWords = $3c0857659fbe7bcd$export$7270d0e0b4d16214[0].length + $3c0857659fbe7bcd$export$7270d0e0b4d16214[1].length;\n            const maxPossibleBlanks = Math.floor(totalWords * 0.3);\n            const actualBlanksCount = Math.min($3c0857659fbe7bcd$export$f69a3a7a70d5284b, maxPossibleBlanks);\n            if ($3c0857659fbe7bcd$export$7270d0e0b4d16214[0].length > 0) {\n                const firstParaBlanks = $3c0857659fbe7bcd$export$7270d0e0b4d16214[1].length > 0 ? Math.floor(actualBlanksCount * ($3c0857659fbe7bcd$export$7270d0e0b4d16214[0].length / totalWords)) : actualBlanksCount;\n                const newRedactionsPara0 = $3c0857659fbe7bcd$export$a49bff6fbcf3a3c9($3c0857659fbe7bcd$export$7270d0e0b4d16214[0], firstParaBlanks);\n                newRedactionsPara0.forEach((r)=>$3c0857659fbe7bcd$export$8d792ae58277cf50[0].push(r));\n            }\n            if ($3c0857659fbe7bcd$export$7270d0e0b4d16214[1].length > 0) {\n                const secondParaBlanks = actualBlanksCount - $3c0857659fbe7bcd$export$8d792ae58277cf50[0].length;\n                const newRedactionsPara1 = $3c0857659fbe7bcd$export$a49bff6fbcf3a3c9($3c0857659fbe7bcd$export$7270d0e0b4d16214[1], secondParaBlanks);\n                newRedactionsPara1.forEach((r)=>$3c0857659fbe7bcd$export$8d792ae58277cf50[1].push(r));\n            }\n            if ($3c0857659fbe7bcd$export$8d792ae58277cf50[0].length + $3c0857659fbe7bcd$export$8d792ae58277cf50[1].length === 0) {\n                if (gameArea) gameArea.innerHTML = '<div class=\"text-center p-4\"><p class=\"text-lg text-red-500 typewriter-text\">Could not generate enough blanks from cached passage. Try different criteria or refresh.</p></div>';\n                if (submitBtn) submitBtn.disabled = true;\n                if (hintBtn) hintBtn.disabled = true;\n                if (typeof stopTimer === 'function') stopTimer();\n                return null;\n            }\n            $3c0857659fbe7bcd$export$f9a124f5758d48a2();\n            return passageData;\n        } else console.warn(\"Cached data for key\", cacheKey, \"is invalid. Fetching new.\");\n    } else {\n        if (forceNewPassage) (0, $gAFfX.debugLog)(\"Forcing new passage fetch, bypassing cache.\", {\n            cacheKey: cacheKey\n        });\n        else (0, $gAFfX.debugLog)(\"Cache miss or invalid cache data. Fetching new passage.\", {\n            cacheKey: cacheKey\n        });\n        let fetchedPassageData = null;\n        try {\n            // Pass century to fetchGutenbergPassage and initialize attemptedBookIds\n            fetchedPassageData = await (0, $64gHy.fetchGutenbergPassage)(category, author, century, []);\n            if (!fetchedPassageData || fetchedPassageData.paragraphs.length === 0) {\n                if (gameArea) gameArea.innerHTML = '<div class=\"text-center p-4\"><p class=\"text-lg text-red-500 typewriter-text\">Could not load a suitable passage after multiple attempts. Please check your API key, network, or try different search criteria.</p></div>';\n                if (submitBtn) submitBtn.disabled = true;\n                if (hintBtn) hintBtn.disabled = true;\n                if (typeof stopTimer === 'function') stopTimer();\n                return;\n            }\n            try {\n                $3c0857659fbe7bcd$var$paragraphCache.set(cacheKey, JSON.stringify(fetchedPassageData));\n                (0, $gAFfX.debugLog)(\"Passage stored in cache\", {\n                    cacheKey: cacheKey\n                });\n            } catch (e) {\n                console.warn(\"Failed to store passage in cache:\", e);\n            }\n            $3c0857659fbe7bcd$export$7270d0e0b4d16214[0] = fetchedPassageData.paragraphs[0].split(/\\s+/).filter((w)=>w.length > 0);\n            $3c0857659fbe7bcd$export$7270d0e0b4d16214[1] = fetchedPassageData.paragraphs.length > 1 ? fetchedPassageData.paragraphs[1].split(/\\s+/).filter((w)=>w.length > 0) : [];\n            // Check if fetchedPassageData and its metadata are not null\n            if (bibliographicArea && fetchedPassageData && fetchedPassageData.metadata) {\n                // Add to previous books history\n                const isAlreadyFetched = $3c0857659fbe7bcd$export$8ea65ab2a8063b73.some((book)=>book.id === fetchedPassageData.metadata.id); // Added non-null assertion as we've checked fetchedPassageData\n                if (!isAlreadyFetched) {\n                    $3c0857659fbe7bcd$export$8ea65ab2a8063b73.unshift(fetchedPassageData.metadata);\n                    if ($3c0857659fbe7bcd$export$8ea65ab2a8063b73.length > 5) $3c0857659fbe7bcd$export$8ea65ab2a8063b73.pop();\n                }\n                let historyHtml = '';\n                if ($3c0857659fbe7bcd$export$8ea65ab2a8063b73.length > 1) {\n                    historyHtml = '<p class=\"text-xs text-typewriter-ink opacity-60 mt-1\">Previously fetched:</p><ul class=\"text-xs list-disc list-inside opacity-60\">';\n                    $3c0857659fbe7bcd$export$8ea65ab2a8063b73.slice(1, 5).forEach((book)=>{\n                        historyHtml += `<li><a href=\"https://www.gutenberg.org/ebooks/${book.id}\" target=\"_blank\" class=\"underline hover:text-typewriter-ribbon\">${book.title} by ${book.author}</a></li>`;\n                    });\n                    historyHtml += '</ul>';\n                }\n                bibliographicArea.innerHTML = `\n            <p class=\"text-sm text-typewriter-ink opacity-80 mb-1\">\n                Currently from: <em><a href=\"https://www.gutenberg.org/ebooks/${fetchedPassageData.metadata.id}\" target=\"_blank\" class=\"underline hover:text-typewriter-ribbon\">${fetchedPassageData.metadata.title}</a></em> by ${fetchedPassageData.metadata.author} (ID: ${fetchedPassageData.metadata.id})\n            </p>\n            ${historyHtml}\n        `;\n                setTimeout(()=>{\n                    if (typeof window !== 'undefined' && window.applyTypewriterEffect) {\n                        const metaElements = bibliographicArea.querySelectorAll('p, em, a, li');\n                        metaElements.forEach((el)=>window.applyTypewriterEffect(el));\n                    }\n                }, 100);\n            }\n        } catch (error) {\n            console.error(\"Error fetching passage:\", error);\n            if (gameArea) gameArea.innerHTML = '<div class=\"text-center p-4\"><p class=\"text-lg text-red-500 typewriter-text\">An error occurred while fetching content. Please check your API key and network connection.</p></div>';\n            if (submitBtn) submitBtn.disabled = true;\n            if (hintBtn) hintBtn.disabled = true;\n            if (typeof stopTimer === 'function') stopTimer();\n            return;\n        }\n        if (!fetchedPassageData) return;\n        $3c0857659fbe7bcd$export$8d792ae58277cf50[0].length = 0;\n        $3c0857659fbe7bcd$export$8d792ae58277cf50[1].length = 0;\n        const totalWords = $3c0857659fbe7bcd$export$7270d0e0b4d16214[0].length + $3c0857659fbe7bcd$export$7270d0e0b4d16214[1].length;\n        const maxPossibleBlanks = Math.floor(totalWords * 0.3);\n        const actualBlanksCount = Math.min($3c0857659fbe7bcd$export$f69a3a7a70d5284b, maxPossibleBlanks);\n        if ($3c0857659fbe7bcd$export$7270d0e0b4d16214[0].length > 0) {\n            const firstParaBlanks = $3c0857659fbe7bcd$export$7270d0e0b4d16214[1].length > 0 ? Math.floor(actualBlanksCount * ($3c0857659fbe7bcd$export$7270d0e0b4d16214[0].length / totalWords)) : actualBlanksCount;\n            const newRedactionsPara0 = $3c0857659fbe7bcd$export$a49bff6fbcf3a3c9($3c0857659fbe7bcd$export$7270d0e0b4d16214[0], firstParaBlanks);\n            newRedactionsPara0.forEach((r)=>$3c0857659fbe7bcd$export$8d792ae58277cf50[0].push(r));\n        }\n        if ($3c0857659fbe7bcd$export$7270d0e0b4d16214[1].length > 0) {\n            const secondParaBlanks = actualBlanksCount - $3c0857659fbe7bcd$export$8d792ae58277cf50[0].length;\n            const newRedactionsPara1 = $3c0857659fbe7bcd$export$a49bff6fbcf3a3c9($3c0857659fbe7bcd$export$7270d0e0b4d16214[1], secondParaBlanks);\n            newRedactionsPara1.forEach((r)=>$3c0857659fbe7bcd$export$8d792ae58277cf50[1].push(r));\n        }\n        if ($3c0857659fbe7bcd$export$8d792ae58277cf50[0].length + $3c0857659fbe7bcd$export$8d792ae58277cf50[1].length === 0) {\n            if (gameArea) gameArea.innerHTML = '<div class=\"text-center p-4\"><p class=\"text-lg text-red-500 typewriter-text\">Could not generate enough blanks. Try different criteria or refresh.</p></div>';\n            if (submitBtn) submitBtn.disabled = true;\n            if (hintBtn) hintBtn.disabled = true;\n            if (typeof stopTimer === 'function') stopTimer();\n            return;\n        }\n        $3c0857659fbe7bcd$export$f9a124f5758d48a2();\n    }\n}\nasync function $3c0857659fbe7bcd$export$f4978f2673be205b(timedOut = false) {\n    if (!$3c0857659fbe7bcd$var$domElements) {\n        console.error(\"DOM elements not initialized for gameLogic.handleSubmission\");\n        return;\n    }\n    const { gameArea: gameArea, submitBtn: submitBtn, hintBtn: hintBtn, resultArea: resultArea } = $3c0857659fbe7bcd$var$domElements;\n    if (typeof stopTimer === 'function') stopTimer();\n    const submitSound = ()=>{\n    // Optional: Add typewriter 'ding' sound effect here\n    };\n    submitSound();\n    const inputs = Array.from(gameArea.querySelectorAll('input[type=\"text\"]'));\n    let correctCount = 0;\n    let totalCount = 0;\n    inputs.forEach((input)=>{\n        totalCount++;\n        const paragraphIdx = Number(input.dataset.paragraph || '0');\n        const wordIdx = Number(input.dataset.index);\n        const originalWord = $3c0857659fbe7bcd$export$7270d0e0b4d16214[paragraphIdx][wordIdx];\n        const guessedWord = input.value.trim();\n        const originalWordClean = originalWord.replace(/[^\\w\\s'-]/g, '').toLowerCase();\n        const guessedWordClean = guessedWord.toLowerCase();\n        const wordSpan = document.createElement('span');\n        wordSpan.className = 'typewriter-text font-bold';\n        if (guessedWordClean === originalWordClean) {\n            correctCount++;\n            wordSpan.textContent = originalWord + ' ';\n            wordSpan.classList.add('text-green-700');\n        } else {\n            wordSpan.textContent = `${guessedWord} [${originalWord}] `;\n            wordSpan.classList.add('text-red-700');\n        }\n        input.parentElement?.insertBefore(wordSpan, input);\n        input.remove();\n    });\n    const neededToPass = Math.ceil(totalCount * 0.6);\n    resultArea.classList.remove('text-green-700', 'text-red-700');\n    if (timedOut) {\n        resultArea.textContent = `Time's up! You got ${correctCount}/${totalCount} correct.`;\n        resultArea.classList.add(correctCount >= neededToPass ? 'text-green-700' : 'text-red-700', 'text-shadow-typewriter');\n    } else {\n        resultArea.textContent = `${correctCount}/${totalCount} correct.`;\n        resultArea.classList.add(correctCount >= neededToPass ? 'text-green-700' : 'text-red-700', 'text-shadow-typewriter');\n    }\n    if (correctCount >= neededToPass) {\n        $3c0857659fbe7bcd$export$2077e0241d6afd3c++;\n        $3c0857659fbe7bcd$export$f69a3a7a70d5284b++;\n        if (resultArea) resultArea.textContent += ` Starting Round ${$3c0857659fbe7bcd$export$2077e0241d6afd3c} with ${$3c0857659fbe7bcd$export$f69a3a7a70d5284b} blanks in 8 seconds...`;\n    } else if (resultArea) resultArea.textContent += ` Getting a new passage in 8 seconds...`;\n    if (submitBtn) submitBtn.disabled = true;\n    if (hintBtn) hintBtn.disabled = true;\n    if (correctCount >= neededToPass) setTimeout(()=>$3c0857659fbe7bcd$export$b5f85e4b788b2112(false), 8000);\n    else setTimeout(()=>$3c0857659fbe7bcd$export$b5f85e4b788b2112(true), 8000);\n}\n\n});\nparcelRegister(\"64gHy\", function(module, exports) {\n\n$parcel$export(module.exports, \"fetchGutenbergPassage\", () => $46b0125df3b201f4$export$75740e8299ebcb60);\n// --- Constants and Config ---\n// Flag to force fallback mode even with valid API key (for debugging)\n\nvar $gAFfX = parcelRequire(\"gAFfX\");\n\nvar $6nwBV = parcelRequire(\"6nwBV\");\n\nvar $84ah7 = parcelRequire(\"84ah7\");\n\nvar $59ye1 = parcelRequire(\"59ye1\");\nconst $46b0125df3b201f4$var$FORCE_FALLBACK = false; // Using the provided API key\n// Empty stub functions for timer (since we're removing timer functionality)\nfunction $46b0125df3b201f4$var$startTimer() {\n// Timer functionality removed\n}\nfunction $46b0125df3b201f4$var$stopTimer() {\n// Timer functionality removed\n}\nasync function $46b0125df3b201f4$export$75740e8299ebcb60(category = null, author = null, century = null, attemptedBookIds = [] // Keep track of books already tried\n) {\n    const MAX_RETRIES = 3;\n    (0, $gAFfX.debugLog)(\"Fetching Gutenberg passage\", {\n        category: category,\n        author: author,\n        century: century,\n        attempt: attemptedBookIds.length + 1\n    });\n    // CHECK 1: Allow real Gutenberg fetching when possible\n    // Only use fallback when necessary (GitHub Pages, missing API key)\n    const TEMP_FORCE_FALLBACK = false; // Enable real Gutenberg fetching\n    // Check for API key and environment\n    const hasValidApiKey = Boolean((0, $6nwBV.getEnvironmentConfig)().OPENROUTER_API_KEY);\n    const isUsingCustomKey = (0, $6nwBV.isUsingUserProvidedApiKey)();\n    const isGitHubPages = window.location.hostname.includes('github.io');\n    (0, $gAFfX.debugLog)(\"Environment check\", {\n        hasValidApiKey: hasValidApiKey,\n        isUsingCustomKey: isUsingCustomKey,\n        isGitHubPages: isGitHubPages,\n        hostname: window.location.hostname,\n        apiKeyFormat: (0, $6nwBV.getEnvironmentConfig)().OPENROUTER_API_KEY.substring(0, 8) + \"...\",\n        forceFallback: $46b0125df3b201f4$var$FORCE_FALLBACK,\n        tempForceFallback: TEMP_FORCE_FALLBACK\n    });\n    // Use hardcoded examples if:\n    // - we're on GitHub Pages AND don't have a custom key, OR\n    // - have no valid API key, OR\n    // - if we're forcing fallback mode (useful for debugging), OR\n    // - temporarily forcing fallback globally\n    // This fallback logic should be outside the retry loop, as it's a global override.\n    if (!hasValidApiKey || $46b0125df3b201f4$var$FORCE_FALLBACK || TEMP_FORCE_FALLBACK) {\n        console.warn(\"Using fallback passage due to missing API key or forced fallback.\");\n        let fallbackParagraphs;\n        let fallbackMetadata = {\n            title: \"Fallback Passage\",\n            author: \"Anonymous\",\n            id: 0\n        };\n        if (category === 'adventure') {\n            fallbackParagraphs = `The intrepid explorer ventured deeper into the uncharted jungle, sweat beading on his brow as he hacked through the dense undergrowth with his machete. Strange bird calls echoed through the canopy above, and the air hung thick with moisture and the sweet scent of exotic flowers. He knew the lost temple lay somewhere ahead, its ancient stones hiding secrets that had remained untouched for centuries.\n\nAs night fell, he made camp beside a small stream, the gentle gurgling of water over stones providing a soothing counterpoint to the mysterious sounds of the jungle. His maps were worn and faded, but they had served him well thus far. Tomorrow would bring new challenges and, perhaps, the discovery that would cement his place in the annals of exploration.`;\n            fallbackMetadata = {\n                title: \"Adventure Story Excerpt\",\n                author: \"Various Authors\",\n                id: 0\n            };\n        } else if (category === 'science') {\n            fallbackParagraphs = `The laboratory hummed with the soft whirring of centrifuges and the occasional beep of monitoring equipment. Dr. Chen carefully pipetted the clear solution into a series of test tubes, her steady hands reflecting years of practiced precision. This experiment represented months of theoretical work, and if successful, could fundamentally alter our understanding of cellular regeneration.\n\nScientific discovery has always balanced on the knife-edge between methodical process and creative insight. The greatest breakthroughs often come not from following established protocols, but from the moments when researchers question fundamental assumptions and pursue the unexpected anomalies that appear in their data. It is this combination of discipline and imagination that drives progress forward.`;\n            fallbackMetadata = {\n                title: \"Scientific Musings\",\n                author: \"Various Authors\",\n                id: 0\n            };\n        } else {\n            // Default paragraphs for any other category or no category\n            fallbackParagraphs = `The ability to think clearly and rationally is essential for making good decisions and solving problems effectively. Critical thinking involves analyzing information objectively and making reasoned judgments based on evidence rather than personal bias or emotional reactions. It requires skills such as attention to detail, logical reasoning, and the willingness to question assumptions.\n\nThroughout history, literature has served as a mirror reflecting the values, concerns, and aspirations of society. Books allow us to experience different perspectives, fostering empathy and understanding across cultural divides. Whether through fiction or non-fiction, the written word preserves human knowledge and invites readers to engage with ideas that may challenge or expand their worldview.`;\n            fallbackMetadata = {\n                title: \"General Knowledge Excerpt\",\n                author: \"Various Authors\",\n                id: 0\n            };\n        }\n        return {\n            paragraphs: fallbackParagraphs.split(/\\n+/).filter((p)=>p.trim().length > 0),\n            metadata: fallbackMetadata\n        };\n    }\n    // Retry loop\n    for(let attempt = 0; attempt < MAX_RETRIES; attempt++){\n        (0, $gAFfX.debugLog)(`Fetch attempt ${attempt + 1} of ${MAX_RETRIES}. Attempted IDs: ${attemptedBookIds.join(', ')}`);\n        const queryParts = [];\n        if (author) queryParts.push(`by author \"${author}\"`);\n        if (category) {\n            if (category.includes('/')) {\n                const categoryCode = category.split('/')[1];\n                if (categoryCode) {\n                    queryParts.push(`in the Gutenberg bookshelf ID \"${categoryCode}\"`);\n                    (0, $gAFfX.debugLog)(`Using bookshelf ID \"${categoryCode}\" from category \"${category}\".`);\n                } else (0, $gAFfX.debugLog)(`Could not extract bookshelf ID from category \"${category}\". Category will be ignored.`);\n            } else queryParts.push(`in the category \"${category}\"`);\n        }\n        if (century) {\n            const centuryNumber = parseInt(century);\n            if (!isNaN(centuryNumber)) queryParts.push(`from the ${centuryNumber + 1}th century`);\n        }\n        let queryString = queryParts.join(' ');\n        let baseQueryInstruction;\n        if (queryParts.length > 0) {\n            baseQueryInstruction = `from Project Gutenberg ${queryString}`;\n            (0, $gAFfX.debugLog)(\"Specific criteria provided: using standard query string.\");\n        } else {\n            // For the initial fetch when no user settings are provided,\n            // use a more specific instruction to encourage true randomness and variety.\n            baseQueryInstruction = \"from a truly random book in classic literature, prioritizing high variety and diverse selections. Please try to pick something unexpected or less common to ensure a unique experience.\";\n            (0, $gAFfX.debugLog)(\"No specific criteria: using new enhanced random query string for initial fetch.\");\n        }\n        let retryInstructions = \"\";\n        if (attempt > 0) retryInstructions = ` This is attempt ${attempt + 1}. Please ensure you select a *different* book than previous attempts.`;\n        if (attemptedBookIds.length > 0) retryInstructions += ` Avoid Project Gutenberg IDs: ${attemptedBookIds.join(', ')}.`;\n        const userQuery = `Please provide a short literary passage (2-3 paragraphs) from Project Gutenberg.\n${baseQueryInstruction ? `Ideally, the passage should be ${baseQueryInstruction}.` : 'The passage can be from any classic literary work.'}\n${retryInstructions}\nInclude the title, author, and Project Gutenberg ID if available.\n\nFormat suggestion:\nTitle: [Book Title]\nAuthor: [Book Author]\nID: [Book ID]\nPassage:\n[The passage text]\n\nIf no passage can be found, please indicate that. Focus on returning a passage, even if all criteria cannot be perfectly met.`;\n        const messages = [\n            {\n                role: 'system',\n                content: 'You are an assistant that helps find and display literary passages from Project Gutenberg. Please provide the passage text along with its title, author, and Project Gutenberg ID if available. Prioritize finding a passage, even if specific search criteria (like category, author, or century) are suggestions and cannot all be met. Avoid adding commentary or analysis not present in the original text.'\n            },\n            {\n                role: 'user',\n                content: userQuery\n            }\n        ];\n        try {\n            // Determine temperature: higher for purely random, default otherwise\n            const temperature = queryParts.length === 0 ? 1.2 : undefined;\n            (0, $gAFfX.debugLog)(`LLM call (attempt ${attempt + 1}) with temperature: ${temperature === undefined ? 'default' : temperature}`);\n            const llmResponseContent = await (0, $84ah7.runAgenticLoop)(messages, [], temperature);\n            if (!llmResponseContent) {\n                console.error(`LLM call (attempt ${attempt + 1}) returned no content.`);\n                if (attempt === MAX_RETRIES - 1) return null; // Last attempt failed\n                await new Promise((resolve)=>setTimeout(resolve, 1000)); // Wait before retrying\n                continue; // Next attempt\n            }\n            (0, $gAFfX.debugLog)(`LLM Web Search Response for Passage (attempt ${attempt + 1}):`, llmResponseContent);\n            let bookTitle = \"Unknown Title\";\n            let bookAuthor = \"Unknown Author\";\n            let bookId = null;\n            let passageText = \"\";\n            const titleMatch = llmResponseContent.match(/Title:\\s*(.*)/i);\n            if (titleMatch && titleMatch[1]) bookTitle = titleMatch[1].trim();\n            const authorMatch = llmResponseContent.match(/Author:\\s*(.*)/i);\n            if (authorMatch && authorMatch[1]) bookAuthor = authorMatch[1].trim();\n            const idMatch = llmResponseContent.match(/ID:\\s*(\\d+)/i);\n            if (idMatch && idMatch[1]) bookId = parseInt(idMatch[1], 10);\n            // Add bookId to attemptedBookIds if valid and not already present\n            if (bookId !== null && !attemptedBookIds.includes(bookId)) attemptedBookIds.push(bookId);\n            const passageMarker = \"Passage:\";\n            const passageStartIndex = llmResponseContent.indexOf(passageMarker);\n            if (passageStartIndex !== -1) passageText = llmResponseContent.substring(passageStartIndex + passageMarker.length).trim();\n            else {\n                let lastMetadataIndex = 0;\n                if (titleMatch) lastMetadataIndex = Math.max(lastMetadataIndex, (titleMatch.index || 0) + titleMatch[0].length);\n                if (authorMatch) lastMetadataIndex = Math.max(lastMetadataIndex, (authorMatch.index || 0) + authorMatch[0].length);\n                if (idMatch) lastMetadataIndex = Math.max(lastMetadataIndex, (idMatch.index || 0) + idMatch[0].length);\n                if (lastMetadataIndex > 0 && lastMetadataIndex < llmResponseContent.length) passageText = llmResponseContent.substring(lastMetadataIndex).trim();\n                else if (!titleMatch && !authorMatch && !idMatch) {\n                    passageText = llmResponseContent.trim();\n                    (0, $gAFfX.debugLog)(\"No metadata markers found, assuming entire response is passage text.\");\n                }\n            }\n            if (!passageText || llmResponseContent.toLowerCase().includes(\"no suitable passage found\")) {\n                console.warn(`Attempt ${attempt + 1}: Could not extract passage text or LLM indicated no passage found.`);\n                if (attempt === MAX_RETRIES - 1) return null; // Last attempt failed\n                await new Promise((resolve)=>setTimeout(resolve, 1000)); // Wait before retrying\n                continue; // Next attempt\n            }\n            let paragraphs = passageText.split(/\\n\\s*\\n/).map((p)=>p.trim()).filter((p)=>p.length > 150 && !p.startsWith('Project Gutenberg') && !p.startsWith('***') && !p.includes('*** END OF ') && !p.startsWith('THE END') && !p.includes('www.gutenberg.org') && !/^\\*+$/.test(p)).slice(0, 10);\n            if (paragraphs.length < 2) {\n                (0, $gAFfX.debugLog)(`Attempt ${attempt + 1}: First parsing didn't yield enough paragraphs, trying alternative.`);\n                paragraphs = passageText.replace(/\\r\\n/g, '\\n').split(/(?:\\n\\s*){2,}/).map((p)=>p.replace(/\\n/g, ' ').trim()).filter((p)=>p.length > 150 && !p.includes('Project Gutenberg')).slice(0, 10);\n            }\n            paragraphs.sort((a, b)=>{\n                const scoreA = Math.min(a.length, 1000) - Math.max(0, 2000 - a.length) + (a.match(/[.!?][\\s\"']/) ? 200 : 0);\n                const scoreB = Math.min(b.length, 1000) - Math.max(0, 2000 - b.length) + (b.match(/[.!?][\\s\"']/) ? 200 : 0);\n                return scoreB - scoreA;\n            });\n            paragraphs = paragraphs.slice(0, 2);\n            if (paragraphs.length === 0) (0, $gAFfX.debugLog)(`Attempt ${attempt + 1}: Failed to extract suitable paragraphs after all parsing attempts.`);\n            // If we have at least one good paragraph, proceed. Otherwise, retry.\n            if (paragraphs.length > 0) {\n                console.log(`Attempt ${attempt + 1}: Successfully extracted ${paragraphs.length} paragraphs.`);\n                return {\n                    paragraphs: paragraphs,\n                    metadata: {\n                        title: bookTitle,\n                        author: bookAuthor,\n                        id: bookId !== null ? bookId : 0\n                    }\n                };\n            } else console.warn(`Attempt ${attempt + 1}: Could only extract ${paragraphs.length} suitable paragraphs. Retrying if attempts remain.`);\n        } catch (error) {\n            console.error(`Error in fetchGutenbergPassage (LLM web search, attempt ${attempt + 1}):`, error);\n        // Loop will continue if attempts < MAX_RETRIES\n        }\n        if (attempt < MAX_RETRIES - 1) await new Promise((resolve)=>setTimeout(resolve, 1000 * (attempt + 1))); // Exponential backoff might be better\n    } // End of retry loop\n    console.error(\"Failed to fetch a suitable passage after all retries.\");\n    return null; // Indicate failure after all retries\n}\n// are now imported from and managed by gameLogic.ts.\n// We use aliasing for round, blanksCount, hintsRemaining, hintedBlanks to avoid naming conflicts if needed,\n// though direct usage of imported names is fine if there are no conflicts.\n// Function to reset game state for a new game (not just a new round)\nfunction $46b0125df3b201f4$var$resetGame() {\n    // We'll use the imported resetGame function from gameLogic\n    (0, $59ye1.resetGame)();\n    // Additional UI updates if needed\n    if ($46b0125df3b201f4$var$gameArea) $46b0125df3b201f4$var$gameArea.innerHTML = '';\n    if ($46b0125df3b201f4$var$resultArea) $46b0125df3b201f4$var$resultArea.textContent = '';\n    if ($46b0125df3b201f4$var$roundInfo) $46b0125df3b201f4$var$roundInfo.textContent = '';\n    if ($46b0125df3b201f4$var$bibliographicArea) $46b0125df3b201f4$var$bibliographicArea.innerHTML = '';\n    $46b0125df3b201f4$var$stopTimer();\n}\n// Cache DOM elements\nlet $46b0125df3b201f4$var$bibliographicArea, $46b0125df3b201f4$var$gameArea, $46b0125df3b201f4$var$resultArea, $46b0125df3b201f4$var$hintBtn, $46b0125df3b201f4$var$submitBtn, $46b0125df3b201f4$var$roundInfo, $46b0125df3b201f4$var$newTextBtn, $46b0125df3b201f4$var$welcomeOverlay, $46b0125df3b201f4$var$startGameBtn;\nfunction $46b0125df3b201f4$var$querySelectorSafe(selector, container = document) {\n    const element = container.querySelector(selector);\n    if (!element) {\n        console.warn(`Element with selector \"${selector}\" not found.`);\n        return null;\n    }\n    return element;\n}\nfunction $46b0125df3b201f4$var$cacheDOMElements() {\n    try {\n        $46b0125df3b201f4$var$bibliographicArea = $46b0125df3b201f4$var$querySelectorSafe('#bibliographic-area') || document.createElement('div');\n        $46b0125df3b201f4$var$gameArea = $46b0125df3b201f4$var$querySelectorSafe('#game-area') || document.createElement('div');\n        $46b0125df3b201f4$var$resultArea = $46b0125df3b201f4$var$querySelectorSafe('#result') || document.createElement('div');\n        $46b0125df3b201f4$var$hintBtn = $46b0125df3b201f4$var$querySelectorSafe('#hint-btn') || document.createElement('button');\n        $46b0125df3b201f4$var$submitBtn = $46b0125df3b201f4$var$querySelectorSafe('#submit-btn') || document.createElement('button');\n        $46b0125df3b201f4$var$roundInfo = $46b0125df3b201f4$var$querySelectorSafe('#round-info') || document.createElement('div');\n        // Settings elements are now handled by Preact components\n        $46b0125df3b201f4$var$newTextBtn = $46b0125df3b201f4$var$querySelectorSafe('#new-text-btn') || document.createElement('button');\n        // Check for welcome overlay elements (may not exist in inference.html)\n        $46b0125df3b201f4$var$welcomeOverlay = $46b0125df3b201f4$var$querySelectorSafe('#welcome-overlay') || document.createElement('div');\n        $46b0125df3b201f4$var$startGameBtn = $46b0125df3b201f4$var$querySelectorSafe('#start-game-btn') || document.createElement('button');\n        console.log(\"DOM Elements cached successfully:\", {\n            gameAreaFound: !!document.querySelector('#game-area'),\n            welcomeOverlayFound: !!document.querySelector('#welcome-overlay'),\n            startGameBtnFound: !!document.querySelector('#start-game-btn')\n        });\n        // Initialize DOM elements for gameLogic service\n        (0, $59ye1.initializeGameDOMElements)({\n            gameArea: $46b0125df3b201f4$var$gameArea,\n            roundInfo: $46b0125df3b201f4$var$roundInfo,\n            submitBtn: $46b0125df3b201f4$var$submitBtn,\n            hintBtn: $46b0125df3b201f4$var$hintBtn,\n            resultArea: $46b0125df3b201f4$var$resultArea,\n            bibliographicArea: $46b0125df3b201f4$var$bibliographicArea\n        });\n    } catch (error) {\n        console.error(\"Error caching DOM elements:\", error);\n    }\n}\n// Make functions globally available for legacy code and avoiding circular imports\nif (typeof window !== 'undefined') {\n    window.startRound = (0, $59ye1.startRound);\n    // findRelatedBooks is removed\n    console.log(\"Added global functions to window object\");\n}\n// Initialize the application when the DOM is loaded\ndocument.addEventListener('DOMContentLoaded', ()=>{\n    // Cache DOM elements\n    $46b0125df3b201f4$var$cacheDOMElements();\n    // Set up event listeners\n    // The startGameBtn event listener is removed from here as it's handled by the WelcomeOverlay component's onStart prop\n    // and the app.tsx component.\n    $46b0125df3b201f4$var$newTextBtn.addEventListener('click', async ()=>{\n        // Fetch a new passage without resetting game state, forcing a new passage\n        await (0, $59ye1.startRound)(true);\n    });\n    $46b0125df3b201f4$var$submitBtn.addEventListener('click', ()=>(0, $59ye1.handleSubmission)());\n// Show welcome overlay\n// The welcome overlay visibility is now primarily managed by the App component's state\n// and the WelcomeOverlay component itself.\n// However, ensuring it's initially visible if not handled by Preact's initial render might still be useful.\n// For now, let's assume Preact handles initial visibility correctly.\n// If issues arise, we might need to revisit this.\n// welcomeOverlay.classList.remove('hidden'); // This line can likely be removed or conditionalized\n});\n\n});\nparcelRegister(\"84ah7\", function(module, exports) {\n\n$parcel$export(module.exports, \"runAgenticLoop\", () => $5df6aadcacb3e0b8$export$24a8f16ac63dee91);\n// src/services/llmService.ts\n\nvar $gAFfX = parcelRequire(\"gAFfX\");\n\nvar $6nwBV = parcelRequire(\"6nwBV\");\nconst $5df6aadcacb3e0b8$export$904054328df186b = [];\nconst $5df6aadcacb3e0b8$export$cb0654e594b33ecc = {\n};\n// For debugging tool calls\nfunction $5df6aadcacb3e0b8$var$logToolCall(message, data) {\n    // Using debugLog for consistency, assuming it's globally available or passed/imported\n    (0, $gAFfX.debugLog)(`[LLM Service Tool Call] ${message}`, data);\n}\nasync function $5df6aadcacb3e0b8$export$783923861e6b7ea4(messages, currentTools, temperature) {\n    const body = {\n        model: 'google/gemini-flash-1.5:online',\n        messages: messages\n    };\n    if (temperature !== undefined) {\n        body.temperature = temperature;\n        (0, $gAFfX.debugLog)(\"LLM Service: Using custom temperature\", temperature);\n    }\n    // If tools are provided, add them. Otherwise, the model will rely on web search.\n    if (currentTools && currentTools.length > 0) {\n        body.tools = currentTools;\n        body.tool_choice = 'auto'; // Let the model decide when to use tools\n        (0, $gAFfX.debugLog)(\"LLM Service: Using tools\", currentTools);\n    } else // If no specific tools, ensure tool_choice is not set or is 'none' if we want to prevent any tool use.\n    // For web search, 'auto' or omitting tool_choice is fine.\n    // The :online suffix handles the web search plugin implicitly.\n    (0, $gAFfX.debugLog)(\"LLM Service: No specific tools provided, relying on web search via :online model suffix.\");\n    (0, $gAFfX.debugLog)(\"LLM Service: OpenRouter API Request\", body);\n    try {\n        const apiKey = (0, $6nwBV.getEnvironmentConfig)().OPENROUTER_API_KEY;\n        const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {\n            method: 'POST',\n            headers: {\n                Authorization: `Bearer ${apiKey}`,\n                'Content-Type': 'application/json',\n                'HTTP-Referer': typeof window !== 'undefined' ? window.location.href : '',\n                'X-Title': 'Cloze'\n            },\n            body: JSON.stringify(body)\n        });\n        if (!response.ok) {\n            let errorData;\n            try {\n                errorData = await response.json();\n            } catch (e) {\n                errorData = await response.text();\n            }\n            const errorMessage = typeof errorData === 'object' && errorData?.error?.message ? errorData.error.message : typeof errorData === 'string' ? errorData : 'Unknown API error';\n            console.error(\"LLM Service: OpenRouter API Error:\", response.status, errorMessage);\n            throw new Error(`OpenRouter API Error: ${response.status} - ${errorMessage}`);\n        }\n        const data = await response.json();\n        (0, $gAFfX.debugLog)(\"LLM Service: OpenRouter API Response\", data);\n        if (!data.choices || !data.choices[0] || !data.choices[0].message) {\n            console.error(\"LLM Service: Invalid response structure from OpenRouter:\", data);\n            throw new Error(\"Invalid response structure from OpenRouter.\");\n        }\n        return data.choices[0].message;\n    } catch (error) {\n        console.error(\"LLM Service: Error calling OpenRouter API:\", error);\n        throw error; // Re-throw to be handled by the caller\n    }\n}\nasync function $5df6aadcacb3e0b8$export$8e4a45ddb5eaee59(assistantResponse) {\n    if (!assistantResponse.tool_calls || assistantResponse.tool_calls.length === 0) throw new Error(\"Assistant response does not contain tool calls.\");\n    const toolCall = assistantResponse.tool_calls[0]; // Assuming one tool call for now\n    const toolName = toolCall.function.name;\n    $5df6aadcacb3e0b8$var$logToolCall(\"Received tool call\", {\n        toolName: toolName,\n        toolCallId: toolCall.id\n    });\n    let toolArgs;\n    try {\n        toolArgs = JSON.parse(toolCall.function.arguments);\n        $5df6aadcacb3e0b8$var$logToolCall(\"Parsed tool arguments\", toolArgs);\n    } catch (error) {\n        const errorObj = error;\n        console.error(\"LLM Service: Failed to parse tool arguments:\", errorObj);\n        return {\n            role: 'tool',\n            tool_call_id: toolCall.id,\n            name: toolName,\n            content: JSON.stringify({\n                error: `Invalid JSON in tool arguments: ${errorObj.message}`\n            })\n        };\n    }\n    const toolFunction = $5df6aadcacb3e0b8$export$cb0654e594b33ecc[toolName];\n    if (!toolFunction) {\n        console.error(`LLM Service: Tool ${toolName} not found in TOOL_MAPPING.`);\n        return {\n            role: 'tool',\n            tool_call_id: toolCall.id,\n            name: toolName,\n            content: JSON.stringify({\n                error: `Tool ${toolName} not found.`\n            })\n        };\n    }\n    try {\n        $5df6aadcacb3e0b8$var$logToolCall(\"Executing tool function\", {\n            name: toolName\n        });\n        const toolResult = await toolFunction(toolArgs);\n        $5df6aadcacb3e0b8$var$logToolCall(\"Tool execution result\", toolResult);\n        return {\n            role: 'tool',\n            tool_call_id: toolCall.id,\n            name: toolName,\n            content: JSON.stringify(toolResult)\n        };\n    } catch (error) {\n        console.error(`LLM Service: Error executing tool ${toolName}:`, error);\n        return {\n            role: 'tool',\n            tool_call_id: toolCall.id,\n            name: toolName,\n            content: JSON.stringify({\n                error: `Error executing tool ${toolName}: ${error.message}`\n            })\n        };\n    }\n}\nasync function $5df6aadcacb3e0b8$export$24a8f16ac63dee91(initialMessages, loopTools, temperature) {\n    let messages = [\n        ...initialMessages\n    ];\n    const MAX_ITERATIONS = 5; // Prevent infinite loops\n    for(let i = 0; i < MAX_ITERATIONS; i++){\n        (0, $gAFfX.debugLog)(`LLM Service: Agentic Loop Iteration ${i + 1}`);\n        const assistantResponse = await $5df6aadcacb3e0b8$export$783923861e6b7ea4(messages, loopTools, temperature); // Pass temperature\n        messages.push(assistantResponse);\n        if (assistantResponse.tool_calls && assistantResponse.tool_calls.length > 0) {\n            // Potentially handle multiple tool calls in the future if needed\n            const toolResponseMessage = await $5df6aadcacb3e0b8$export$8e4a45ddb5eaee59(assistantResponse);\n            messages.push(toolResponseMessage);\n        } else // No tool calls, loop finishes, return assistant's content\n        return assistantResponse.content ?? null;\n    }\n    console.warn(\"LLM Service: Agentic loop reached max iterations.\");\n    const lastMessage = messages.length > 0 ? messages[messages.length - 1] : null;\n    if (lastMessage && lastMessage.role === 'assistant' && lastMessage.content) return lastMessage.content;\n    return \"Agentic loop completed without a final assistant message or an error occurred.\";\n}\n\n});\n\n\n\n\nparcelRequire(\"64gHy\");\n\n//# sourceMappingURL=inference.39e3d91a.js.map\n","// src/utils/environmentConfig.ts\n\nimport { debugLog } from './debugLog';\n\n/**\n * Environment configuration management for the application\n * Handles secure storage and retrieval of sensitive configuration values\n */\n\n// Define the default safe fallback key (will be used if no key is found)\n// This key is obfuscated to prevent direct copying\nconst ENCODED_DEFAULT_KEY = 'c2stb3ItdjEtNGY4MmQ3NDBlZmQyNjlhY2IwYTA4MGIzMTgyNTQ5NDlhMTQ5Y2FlYTZmNzFkODAxMGM0MDJkNWQ5ZGViYjQ1Zg==';\n\n/**\n * Interface defining the environment configuration structure\n */\nexport interface EnvironmentConfig {\n  OPENROUTER_API_KEY: string;\n  IS_REMOTE_INTERFACE: boolean;\n  // Add other environment variables here as needed\n}\n\n/**\n * Determines if the application is running in a remote interface like GitHub Pages\n * @returns boolean indicating if this is a remote interface\n */\nexport function isRemoteInterface(): boolean {\n  return window.location.hostname.includes('github.io') || \n         window.location.hostname === 'cloze-reader.vercel.app' ||\n         window.location.protocol === 'file:';\n}\n\n/**\n * Retrieves the current environment configuration\n * Prioritizes user-provided values in localStorage over defaults\n * In remote interfaces, always uses the default key for security\n */\nexport function getEnvironmentConfig(): EnvironmentConfig {\n  const remote = isRemoteInterface();\n  \n  // Try to get user-set API key from localStorage\n  const userProvidedKey = localStorage.getItem('openrouter_api_key');\n  const isUserKeyValid = Boolean(userProvidedKey) && \n                          userProvidedKey!.startsWith('sk-or-') && \n                          userProvidedKey!.length > 20;\n  \n  // Decode the default key\n  const defaultKey = atob(ENCODED_DEFAULT_KEY);\n  \n  // Use default key if in remote interface, otherwise use user key if valid\n  const apiKey = remote ? defaultKey : (isUserKeyValid ? userProvidedKey! : defaultKey);\n  \n  debugLog(\"Environment config loaded\", { \n    isRemoteInterface: remote,\n    usingUserKey: !remote && isUserKeyValid,\n    keyFormat: apiKey.substring(0, 8) + \"...\"\n  });\n  \n  return {\n    OPENROUTER_API_KEY: apiKey,\n    IS_REMOTE_INTERFACE: remote\n  };\n}\n\n/**\n * Checks if a user-provided API key is being used\n * Useful for determining if we're using a default key or user-provided key\n * Always returns false in remote interfaces for security\n */\nexport function isUsingUserProvidedApiKey(): boolean {\n  // In remote interfaces, always report as using the default key\n  if (isRemoteInterface()) {\n    return false;\n  }\n  \n  const userProvidedKey = localStorage.getItem('openrouter_api_key');\n  return Boolean(userProvidedKey) && \n         userProvidedKey!.startsWith('sk-or-') && \n         userProvidedKey!.length > 20;\n}\n\n/**\n * Sets a user-provided API key in localStorage\n * Also validates the key format\n * In remote interfaces, this is a no-op for security\n * @param key The API key to set\n * @returns Whether the key was valid and set successfully\n */\nexport function setUserApiKey(key: string): boolean {\n  // In remote interfaces, don't allow setting custom API keys\n  if (isRemoteInterface()) {\n    debugLog(\"Cannot set custom API key in remote interface\");\n    return false;\n  }\n  \n  const trimmedKey = key.trim();\n  if (trimmedKey && trimmedKey.startsWith('sk-or-') && trimmedKey.length > 20) {\n    localStorage.setItem('openrouter_api_key', trimmedKey);\n    return true;\n  }\n  return false;\n}\n","// src/utils/debugLog.ts\n\n/**\n * Helper function to add detailed debug logs to the console.\n * Includes a timestamp and optional data payload.\n * @param message The main log message.\n * @param data Optional data to be logged as a JSON string.\n */\nexport function debugLog(message: string, data?: any): void {\n  const timestamp = new Date().toISOString();\n  console.log(`[DEBUG ${timestamp}] ${message}`);\n  if (data !== undefined) {\n    try {\n      // Attempt to stringify, handling potential circular references or large objects\n      const jsonData = JSON.stringify(data, (key, value) => {\n        if (value instanceof HTMLElement) {\n          return `HTMLElement (${value.tagName}${value.id ? '#' + value.id : ''})`;\n        }\n        // Add more complex object handling here if needed\n        return value;\n      }, 2);\n      console.log(jsonData);\n    } catch (error) {\n      console.log('[DEBUG Data Stringify Error]', error);\n      console.log('[DEBUG Raw Data]', data); // Log raw data if stringify fails\n    }\n  }\n}\n","// src/services/gameLogic.ts\n\nimport { debugLog } from '@/utils/debugLog';\n\n// --- Type Definitions (specific to game logic) ---\n// If ScoredWord is only used here, keep it here. Otherwise, consider a shared types file.\ninterface ScoredWord {\n  index: number;\n  score: number;\n}\n\nexport interface ParagraphCacheItem {\n  value: string;\n  timestamp: number;\n}\n\nexport interface ParagraphCache {\n  cache: Record<string, ParagraphCacheItem>;\n  maxSize: number;\n  set: (key: string, value: string) => void;\n  get: (key: string) => string | null;\n  init: () => void;\n}\n\n// --- Caching ---\nconst paragraphCache: ParagraphCache = {\n  cache: {},\n  maxSize: 10,\n  set: function(key, value) {\n    if (Object.keys(this.cache).length >= this.maxSize) {\n      const oldestKey = Object.keys(this.cache)[0];\n      delete this.cache[oldestKey];\n    }\n    this.cache[key] = { value, timestamp: Date.now() };\n    try { localStorage.setItem('paragraphCache', JSON.stringify(this.cache)); }\n    catch (e) { console.warn('Could not save cache to localStorage', e); }\n  },\n  get: function(key) {\n    const item = this.cache[key];\n    if (!item) return null;\n    if (Date.now() - item.timestamp > 24 * 60 * 60 * 1000) { // 24hr expiry\n      delete this.cache[key];\n      try { localStorage.setItem('paragraphCache', JSON.stringify(this.cache)); }\n      catch (e) { console.warn('Could not update cache in localStorage', e); }\n      return null;\n    }\n    return item.value;\n  },\n  init: function() {\n    try {\n      const saved = localStorage.getItem('paragraphCache');\n      if (saved) this.cache = JSON.parse(saved);\n    } catch (e) { console.warn('Could not load cache from localStorage', e); this.cache = {}; }\n  }\n};\n\n// Initialize the cache when the module is loaded\nparagraphCache.init();\n\n// --- Game Logic Functions ---\n\n/**\n * Chooses words to redact from a list of words based on a scoring mechanism.\n * @param words The array of words in the paragraph.\n * @param count The desired number of redactions.\n * @returns An array of indices to be redacted.\n */\nexport function chooseRedactions(words: string[], count: number): number[] {\n  const indices: number[] = [];\n  if (words.length === 0 || count === 0) return indices;\n\n  const functionWords = new Set([\n    'the', 'a', 'an', 'and', 'or', 'but', 'if', 'of', 'at', 'by', 'for', 'with', 'about',\n    'to', 'from', 'in', 'on', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have',\n    'has', 'had', 'do', 'does', 'did', 'will', 'would', 'shall', 'should', 'can', 'could',\n    'may', 'might', 'must', 'that', 'which', 'who', 'whom', 'whose', 'this', 'these',\n    'those', 'am', 'i', 'we', 'you', 'he', 'she', 'they', 'we', 'it' // Corrected: removed duplicate 'we'\n  ]);\n\n  const scoredWords: ScoredWord[] = words.map((word, index) => {\n    const cleanWord = word.toLowerCase().replace(/[^\\w]/g, '');\n    let score = 0;\n    score += cleanWord.length * 2;\n    if (functionWords.has(cleanWord)) {\n      score -= 10;\n    }\n    if (index > 0 && word[0] === word[0].toUpperCase() && word[0].match(/[A-Z]/)) {\n      score += 5;\n    }\n    score += Math.random() * 2;\n    return { index, score };\n  });\n\n  scoredWords.sort((a, b) => b.score - a.score);\n\n  const actualCount = Math.min(count, words.length);\n  const candidatePoolSize = Math.min(actualCount * 2, words.length);\n  const topCandidates = scoredWords.slice(0, candidatePoolSize);\n\n  while (indices.length < actualCount && topCandidates.length > 0) {\n    const randomIndex = Math.floor(Math.random() * topCandidates.length);\n    const selectedWord = topCandidates.splice(randomIndex, 1)[0];\n    indices.push(selectedWord.index);\n  }\n\n  return indices.sort((a, b) => a - b);\n}\n\n/**\n * Extracts key terms from an array of words based on frequency, excluding common words.\n * @param words The array of words to process.\n * @param count The number of key terms to extract.\n * @returns An array of key terms.\n */\nexport function extractKeyTerms(words: string[], count = 3): string[] {\n  const commonWords = new Set(['the', 'and', 'of', 'to', 'a', 'in', 'that', 'it', 'is', 'was', 'were', 'for', 'on', 'with', 'as', 'by', 'an', 'be', 'at', 'or', 'i', 'he', 'she', 'they', 'we', 'you', 'my', 'his', 'her', 'its', 'our', 'your', 'them', 'us', 'me', 'had', 'has', 'have', 'do', 'does', 'did', 'will', 'would', 'should', 'can', 'could', 'may', 'might', 'must', 'not', 'no', 'so', 'if', 'but', 'very', 'just', 'from', 'into', 'out', 'up', 'down', 'over', 'under', 'again', 'then', 'once', 'here', 'there', 'when', 'where', 'why', 'how', 'all', 'any', 'both', 'each', 'few', 'more', 'most', 'other', 'some', 'such', 'than', 'too', 'very', 's', 't', 'd', 'll', 'm', 'o', 're', 've']);\n  const frequency: Record<string, number> = {};\n  words.forEach(word => {\n    const cleanWord = word.toLowerCase().replace(/[^a-z0-9']/g, '');\n    if (cleanWord.length > 3 && !commonWords.has(cleanWord) && !/^\\d+$/.test(cleanWord)) {\n      frequency[cleanWord] = (frequency[cleanWord] || 0) + 1;\n    }\n  });\n  return Object.entries(frequency)\n    .sort(([,a],[,b]) => b-a)\n    .slice(0, count)\n    .map(([term]) => term);\n}\n\n// --- Game State Variables ---\n// These will be managed within this module.\nexport let paragraphsWords: string[][] = [[], []];\nexport let redactedIndices: number[][] = [[], []];\nexport let round = 1;\nexport let blanksCount = 1;\nexport let hintsRemaining = 5;\nexport let hintedBlanks: Set<string> = new Set();\nexport let previousBooks: { title: string; author: string; id: number }[] = [];\n\n// --- DOM Element References ---\n// These will be initialized by a function called from main.ts or passed as arguments.\n// For now, assuming they will be passed to functions that need them or queried internally.\n// Let's define placeholders that functions can expect to be populated.\ninterface GameDOMElements {\n  gameArea: HTMLElement;\n  roundInfo: HTMLElement;\n  submitBtn: HTMLButtonElement;\n  hintBtn: HTMLButtonElement;\n  resultArea: HTMLElement;\n  bibliographicArea: HTMLElement; // Added bibliographicArea\n}\n\nlet domElements: GameDOMElements | null = null;\n\nexport function initializeGameDOMElements(elements: GameDOMElements) {\n  domElements = elements;\n}\n\n\n// --- Timer and UI Effect Stubs/References ---\n// These functions are currently in main.ts. For now, we'll assume they are globally available\n// or will be passed/imported eventually.\ndeclare function startTimer(): void;\ndeclare function stopTimer(): void; // Added for completeness, though renderRound doesn't call it directly\ndeclare global {\n  interface Window {\n    applyTypewriterEffect: (element?: HTMLElement) => void;\n  }\n}\n\n/**\n * Renders the current round of the game, displaying paragraphs with redactions.\n */\nexport function renderRound() {\n  if (!domElements) {\n    console.error(\"DOM elements not initialized for gameLogic.renderRound\");\n    return;\n  }\n\n  const { gameArea, roundInfo, submitBtn, hintBtn, resultArea } = domElements;\n\n  const totalBlanks = redactedIndices[0].length + redactedIndices[1].length;\n  roundInfo.textContent = `Round ${round}  ${totalBlanks} blanks`;\n  gameArea.innerHTML = '';\n\n  if (paragraphsWords[0].length === 0 && paragraphsWords[1].length === 0) {\n    gameArea.innerHTML = '<p class=\"text-red-500\">Error: No paragraphs loaded.</p>';\n    submitBtn.disabled = true;\n    hintBtn.disabled = true;\n    // stopTimer(); // stopTimer is not directly called here but good to note dependency\n    return;\n  }\n\n  for (let pIdx = 0; pIdx < 2; pIdx++) {\n    if (paragraphsWords[pIdx].length === 0) continue;\n\n    const paragraphElement = document.createElement('p');\n    paragraphElement.className = 'typewriter-text leading-relaxed break-words mb-6';\n    paragraphElement.style.maxWidth = '100%';\n    paragraphElement.style.overflowWrap = 'break-word';\n    gameArea.appendChild(paragraphElement);\n\n    paragraphsWords[pIdx].forEach((word, idx) => {\n      if (redactedIndices[pIdx].includes(idx)) {\n        const input = document.createElement('input');\n        input.type = 'text';\n        input.dataset.index = String(idx);\n        input.dataset.paragraph = String(pIdx);\n        input.placeholder = '_____';\n        // Enhanced styling for input boxes\n        input.className = 'border-b-2 border-typewriter-ink w-24 mx-1 text-center bg-transparent focus:outline-none focus:border-typewriter-ribbon focus:ring-1 focus:ring-typewriter-ribbon rounded-sm px-1 py-0.5 text-typewriter-ink placeholder-typewriter-ink placeholder-opacity-50';\n\n\n        input.addEventListener('keydown', (e) => {\n          if (e.key.length === 1) {\n            input.classList.add('shadow-typewriter-pressed');\n            setTimeout(() => input.classList.remove('shadow-typewriter-pressed'), 100);\n          }\n        });\n\n        input.addEventListener('input', () => {\n          const allFilled = Array.from(gameArea.querySelectorAll<HTMLInputElement>('input[type=\"text\"]')).every(i => i.value.trim() !== '');\n          submitBtn.disabled = !allFilled;\n        });\n        paragraphElement.appendChild(input);\n        paragraphElement.appendChild(document.createTextNode(' '));\n\n        input.addEventListener('focus', () => {\n          if (!domElements) return; // Guard against null domElements\n          const paragraphIdx = Number(input.dataset.paragraph);\n          const wordIdx = Number(input.dataset.index);\n          const blankKey = `${paragraphIdx}-${wordIdx}`;\n\n          domElements.hintBtn.disabled = hintsRemaining <= 0 || hintedBlanks.has(blankKey);\n\n          domElements.hintBtn.onclick = () => {\n            if (hintsRemaining > 0 && !hintedBlanks.has(blankKey)) {\n              const originalWord = paragraphsWords[paragraphIdx][wordIdx];\n\n              if (originalWord) {\n                const hintText = `Starts with \"${originalWord[0]}\", length ${originalWord.length}.`;\n                const hintDiv = document.createElement('div');\n                hintDiv.className = 'fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50';\n                hintDiv.innerHTML = `\n                  <div class=\"bg-aged-paper p-6 rounded shadow-typewriter max-w-md text-center typewriter-text\">\n                    <h3 class=\"text-xl font-bold mb-4 text-shadow-typewriter\">Hint</h3>\n                    <p>${hintText}</p>\n                    <button class=\"mt-4 px-4 py-2 typewriter-key hover:bg-aged-paper\">Got it</button>\n                  </div>\n                `;\n                document.body.appendChild(hintDiv);\n\n                const closeHint = () => document.body.removeChild(hintDiv);\n                hintDiv.querySelector('button')?.addEventListener('click', closeHint);\n                hintDiv.addEventListener('click', (e) => {\n                  if (e.target === hintDiv) closeHint();\n                });\n\n                hintsRemaining--;\n                if (domElements) domElements.hintBtn.textContent = `Hint (${hintsRemaining})`;\n                hintedBlanks.add(blankKey);\n                input.classList.add('hinted-blank');\n                if (domElements) domElements.hintBtn.disabled = hintsRemaining <= 0 || hintedBlanks.has(blankKey);\n              }\n            }\n          };\n        });\n      } else {\n        const wordSpan = document.createElement('span');\n        wordSpan.textContent = word + ' ';\n        wordSpan.className = 'typewriter-text';\n        paragraphElement.appendChild(wordSpan);\n      }\n    });\n  }\n\n  const totalRedactedCount = redactedIndices[0].length + redactedIndices[1].length;\n  submitBtn.disabled = totalRedactedCount === 0;\n  hintBtn.disabled = hintsRemaining <= 0 || totalRedactedCount === 0;\n  resultArea.textContent = '';\n\n  // Assuming startTimer is globally available or will be handled\n  if (typeof startTimer === 'function') {\n    startTimer();\n  }\n\n\n  setTimeout(() => {\n    if (typeof window !== 'undefined' && window.applyTypewriterEffect) {\n      window.applyTypewriterEffect();\n    }\n  }, 100);\n}\n\n/**\n * Resets the game state for a new game.\n */\nexport function resetGame() {\n  if (!domElements) {\n    console.error(\"DOM elements not initialized for gameLogic.resetGame\");\n    return;\n  }\n  const { gameArea, resultArea, roundInfo, bibliographicArea } = domElements;\n\n  round = 1;\n  blanksCount = 1;\n  hintsRemaining = 5;\n  hintedBlanks.clear();\n  paragraphsWords[0] = [];\n  paragraphsWords[1] = [];\n  redactedIndices[0] = [];\n  redactedIndices[1] = [];\n  previousBooks = []; // Reset previous books on a full game reset\n\n  if (gameArea) gameArea.innerHTML = '';\n  if (resultArea) resultArea.textContent = '';\n  if (roundInfo) roundInfo.textContent = '';\n  if (bibliographicArea) bibliographicArea.innerHTML = '';\n\n  if (typeof stopTimer === 'function') {\n    stopTimer();\n  }\n  debugLog(\"Game reset in gameLogic.ts\");\n}\n\n\nimport { fetchGutenbergPassage } from '@/main'; \n\n/**\n * Starts a new round of the game by fetching a new passage and rendering it.\n */\nexport async function startRound(forceNewPassage: boolean = false) {\n  if (!domElements) {\n    console.error(\"DOM elements not initialized for gameLogic.startRound\");\n    return;\n  }\n  const { gameArea, roundInfo, submitBtn, hintBtn, resultArea, bibliographicArea } = domElements;\n\n  hintsRemaining = 3; \n  if (hintBtn) hintBtn.textContent = `Hint (${hintsRemaining})`;\n  if (submitBtn) submitBtn.disabled = true;\n  if (hintBtn) hintBtn.disabled = true;\n  if (gameArea) gameArea.innerHTML = '<div class=\"text-center p-4\"><p class=\"text-lg typewriter-text\">Fetching new paragraphs from Gutenberg...</p><p class=\"text-sm mt-2 text-opacity-70\">*click* *clack* *ding*</p></div>';\n  if (resultArea) resultArea.textContent = '';\n  hintedBlanks.clear();\n  if (typeof stopTimer === 'function') { \n    stopTimer(); \n  }\n\n  if (bibliographicArea) {\n      bibliographicArea.innerHTML = '';\n  }\n\n  const category = localStorage.getItem('game_category') || '';\n  const author = localStorage.getItem('game_author') || '';\n  const century = localStorage.getItem('game_century') || ''; // Fetch century as well\n\n  let cacheKey = `passage_${category || 'any'}_${author || 'any'}_${century || 'any'}`; // Include century in cache key\n\n  // If all search parameters are empty, it's a \"random\" request.\n  // Add a random component to the cache key to ensure a fresh fetch for \"truly random\" initial passages,\n  // unless forceNewPassage is explicitly false (which might be used for specific reloads of the *same* random passage).\n  // However, startRound is usually called with forceNewPassage=true for the very first load via app.tsx.\n  if (!category && !author && !century && forceNewPassage) {\n    cacheKey = `passage_random_${Date.now()}_${Math.random().toString(36).substring(7)}`;\n    debugLog(\"Generated unique cache key for initial random passage:\", { cacheKey });\n  }\n\n  const cachedPassage = paragraphCache.get(cacheKey);\n  // For truly random initial fetches, we want to bypass cache even if forceNewPassage wasn't explicitly true,\n  // but the logic above already makes the cacheKey unique, effectively bypassing it.\n  if (!forceNewPassage && cachedPassage && !cacheKey.startsWith('passage_random_')) {\n    debugLog(\"Serving passage from cache\", { cacheKey });\n    const parsedCache = JSON.parse(cachedPassage);\n     if (parsedCache && parsedCache.paragraphs && Array.isArray(parsedCache.paragraphs)) {\n        const passageData = {\n            paragraphs: parsedCache.paragraphs,\n            metadata: parsedCache.metadata || null\n        };\n        if (bibliographicArea && passageData.metadata) {\n            // Add to previous books history if not already there\n            const isAlreadyFetched = previousBooks.some(book => book.id === passageData.metadata!.id);\n            if (!isAlreadyFetched) {\n              previousBooks.unshift(passageData.metadata);\n              if (previousBooks.length > 5) {\n                previousBooks.pop();\n              }\n            }\n\n            let historyHtml = '';\n            if (previousBooks.length > 1) {\n                historyHtml = '<p class=\"text-xs text-typewriter-ink opacity-60 mt-1\">Previously fetched:</p><ul class=\"text-xs list-disc list-inside opacity-60\">';\n                previousBooks.slice(1, 5).forEach(book => {\n                    historyHtml += `<li><a href=\"https://www.gutenberg.org/ebooks/${book.id}\" target=\"_blank\" class=\"underline hover:text-typewriter-ribbon\">${book.title} by ${book.author}</a></li>`;\n                });\n                historyHtml += '</ul>';\n            }\n            bibliographicArea.innerHTML = `\n                <p class=\"text-sm text-typewriter-ink opacity-80 mb-1\">\n                    (Cached) Currently from: <em><a href=\"https://www.gutenberg.org/ebooks/${passageData.metadata.id}\" target=\"_blank\" class=\"underline hover:text-typewriter-ribbon\">${passageData.metadata.title}</a></em> by ${passageData.metadata.author} (ID: ${passageData.metadata.id})\n                </p>\n                ${historyHtml}\n            `;\n            setTimeout(() => {\n                if (typeof window !== 'undefined' && (window as any).applyTypewriterEffect) {\n                    const metaElements = bibliographicArea.querySelectorAll('p, em, a, li');\n                    metaElements.forEach(el => (window as any).applyTypewriterEffect(el));\n                }\n            }, 100);\n        }\n        paragraphsWords[0] = passageData.paragraphs[0].split(/\\s+/).filter((w: string) => w.length > 0);\n        paragraphsWords[1] = passageData.paragraphs.length > 1 ?\n          passageData.paragraphs[1].split(/\\s+/).filter((w: string) => w.length > 0) : [];\n\n        redactedIndices[0].length = 0;\n        redactedIndices[1].length = 0;\n        const totalWords = paragraphsWords[0].length + paragraphsWords[1].length;\n        const maxPossibleBlanks = Math.floor(totalWords * 0.3);\n        const actualBlanksCount = Math.min(blanksCount, maxPossibleBlanks);\n\n        if (paragraphsWords[0].length > 0) {\n          const firstParaBlanks = paragraphsWords[1].length > 0 ?\n            Math.floor(actualBlanksCount * (paragraphsWords[0].length / totalWords)) :\n            actualBlanksCount;\n          const newRedactionsPara0 = chooseRedactions(paragraphsWords[0], firstParaBlanks);\n          newRedactionsPara0.forEach(r => redactedIndices[0].push(r));\n        }\n        if (paragraphsWords[1].length > 0) {\n          const secondParaBlanks = actualBlanksCount - redactedIndices[0].length;\n          const newRedactionsPara1 = chooseRedactions(paragraphsWords[1], secondParaBlanks);\n          newRedactionsPara1.forEach(r => redactedIndices[1].push(r));\n        }\n\n        if ((redactedIndices[0].length + redactedIndices[1].length) === 0) {\n          if (gameArea) gameArea.innerHTML = '<div class=\"text-center p-4\"><p class=\"text-lg text-red-500 typewriter-text\">Could not generate enough blanks from cached passage. Try different criteria or refresh.</p></div>';\n          if (submitBtn) submitBtn.disabled = true;\n          if (hintBtn) hintBtn.disabled = true;\n          if (typeof stopTimer === 'function') { \n            stopTimer();\n          }\n          return null;\n        }\n\n        renderRound();\n        return passageData;\n     } else {\n        console.warn(\"Cached data for key\", cacheKey, \"is invalid. Fetching new.\");\n     }\n  } else {\n    if (forceNewPassage) {\n      debugLog(\"Forcing new passage fetch, bypassing cache.\", { cacheKey });\n    } else {\n      debugLog(\"Cache miss or invalid cache data. Fetching new passage.\", { cacheKey });\n    }\n    \n  let fetchedPassageData: Awaited<ReturnType<typeof fetchGutenbergPassage>> = null;\n  \n  try {\n    // Pass century to fetchGutenbergPassage and initialize attemptedBookIds\n    fetchedPassageData = await fetchGutenbergPassage(category, author, century, []); \n    \n    if (!fetchedPassageData || fetchedPassageData.paragraphs.length === 0) {\n      if (gameArea) gameArea.innerHTML = '<div class=\"text-center p-4\"><p class=\"text-lg text-red-500 typewriter-text\">Could not load a suitable passage after multiple attempts. Please check your API key, network, or try different search criteria.</p></div>';\n      if (submitBtn) submitBtn.disabled = true;\n      if (hintBtn) hintBtn.disabled = true;\n      if (typeof stopTimer === 'function') { \n        stopTimer();\n      }\n      return;\n    }\n  \n    try {\n      paragraphCache.set(cacheKey, JSON.stringify(fetchedPassageData));\n      debugLog(\"Passage stored in cache\", { cacheKey });\n    } catch (e) {\n      console.warn(\"Failed to store passage in cache:\", e);\n    }\n  \n    paragraphsWords[0] = fetchedPassageData.paragraphs[0].split(/\\s+/).filter((w: string) => w.length > 0);\n    paragraphsWords[1] = fetchedPassageData.paragraphs.length > 1 ?\n      fetchedPassageData.paragraphs[1].split(/\\s+/).filter((w: string) => w.length > 0) : [];\n  \n    // Check if fetchedPassageData and its metadata are not null\n    if (bibliographicArea && fetchedPassageData && fetchedPassageData.metadata) {\n        // Add to previous books history\n        const isAlreadyFetched = previousBooks.some(book => book.id === fetchedPassageData!.metadata!.id); // Added non-null assertion as we've checked fetchedPassageData\n        if (!isAlreadyFetched) {\n          previousBooks.unshift(fetchedPassageData.metadata); \n          if (previousBooks.length > 5) { \n            previousBooks.pop();\n          }\n        }\n\n        let historyHtml = '';\n        if (previousBooks.length > 1) { \n            historyHtml = '<p class=\"text-xs text-typewriter-ink opacity-60 mt-1\">Previously fetched:</p><ul class=\"text-xs list-disc list-inside opacity-60\">';\n            previousBooks.slice(1, 5).forEach(book => { \n                historyHtml += `<li><a href=\"https://www.gutenberg.org/ebooks/${book.id}\" target=\"_blank\" class=\"underline hover:text-typewriter-ribbon\">${book.title} by ${book.author}</a></li>`;\n            });\n            historyHtml += '</ul>';\n        }\n\n        bibliographicArea.innerHTML = `\n            <p class=\"text-sm text-typewriter-ink opacity-80 mb-1\">\n                Currently from: <em><a href=\"https://www.gutenberg.org/ebooks/${fetchedPassageData.metadata.id}\" target=\"_blank\" class=\"underline hover:text-typewriter-ribbon\">${fetchedPassageData.metadata.title}</a></em> by ${fetchedPassageData.metadata.author} (ID: ${fetchedPassageData.metadata.id})\n            </p>\n            ${historyHtml}\n        `;\n        setTimeout(() => {\n            if (typeof window !== 'undefined' && (window as any).applyTypewriterEffect) {\n                const metaElements = bibliographicArea.querySelectorAll('p, em, a, li');\n                metaElements.forEach(el => (window as any).applyTypewriterEffect(el));\n            }\n        }, 100);\n    }\n  } catch (error) {\n    console.error(\"Error fetching passage:\", error);\n    if (gameArea) gameArea.innerHTML = '<div class=\"text-center p-4\"><p class=\"text-lg text-red-500 typewriter-text\">An error occurred while fetching content. Please check your API key and network connection.</p></div>';\n    if (submitBtn) submitBtn.disabled = true;\n    if (hintBtn) hintBtn.disabled = true;\n    if (typeof stopTimer === 'function') {\n      stopTimer();\n    }\n    return;\n  }\n  \n  if (!fetchedPassageData) return;\n\n  redactedIndices[0].length = 0;\n  redactedIndices[1].length = 0;\n  const totalWords = paragraphsWords[0].length + paragraphsWords[1].length;\n  const maxPossibleBlanks = Math.floor(totalWords * 0.3);\n  const actualBlanksCount = Math.min(blanksCount, maxPossibleBlanks);\n\n  if (paragraphsWords[0].length > 0) {\n    const firstParaBlanks = paragraphsWords[1].length > 0 ?\n      Math.floor(actualBlanksCount * (paragraphsWords[0].length / totalWords)) :\n      actualBlanksCount;\n    const newRedactionsPara0 = chooseRedactions(paragraphsWords[0], firstParaBlanks);\n    newRedactionsPara0.forEach(r => redactedIndices[0].push(r));\n  }\n  if (paragraphsWords[1].length > 0) {\n    const secondParaBlanks = actualBlanksCount - redactedIndices[0].length;\n    const newRedactionsPara1 = chooseRedactions(paragraphsWords[1], secondParaBlanks);\n    newRedactionsPara1.forEach(r => redactedIndices[1].push(r));\n  }\n\n  if ((redactedIndices[0].length + redactedIndices[1].length) === 0) {\n    if (gameArea) gameArea.innerHTML = '<div class=\"text-center p-4\"><p class=\"text-lg text-red-500 typewriter-text\">Could not generate enough blanks. Try different criteria or refresh.</p></div>';\n    if (submitBtn) submitBtn.disabled = true;\n    if (hintBtn) hintBtn.disabled = true;\n    if (typeof stopTimer === 'function') { \n      stopTimer();\n    }\n    return;\n  }\n\n  renderRound();\n}\n}\n\n/**\n * Handles the submission of the user's guesses, checks answers, and updates the UI.\n * @param timedOut Whether the submission was triggered by a timer timeout.\n */\nexport async function handleSubmission(timedOut = false) {\n  if (!domElements) {\n    console.error(\"DOM elements not initialized for gameLogic.handleSubmission\");\n    return;\n  }\n  const { gameArea, submitBtn, hintBtn, resultArea } = domElements;\n\n  if (typeof stopTimer === 'function') { \n    stopTimer(); \n  }\n\n  const submitSound = () => {\n    // Optional: Add typewriter 'ding' sound effect here\n  };\n  submitSound();\n\n  const inputs = Array.from(gameArea.querySelectorAll<HTMLInputElement>('input[type=\"text\"]'));\n  let correctCount = 0;\n  let totalCount = 0;\n\n  inputs.forEach(input => {\n    totalCount++;\n    const paragraphIdx = Number(input.dataset.paragraph || '0');\n    const wordIdx = Number(input.dataset.index);\n\n    const originalWord = paragraphsWords[paragraphIdx][wordIdx];\n    const guessedWord = input.value.trim(); \n\n    const originalWordClean = originalWord.replace(/[^\\w\\s'-]/g, '').toLowerCase();\n    const guessedWordClean = guessedWord.toLowerCase();\n\n    const wordSpan = document.createElement('span');\n    wordSpan.className = 'typewriter-text font-bold'; \n\n    if (guessedWordClean === originalWordClean) {\n      correctCount++;\n      wordSpan.textContent = originalWord + ' '; \n      wordSpan.classList.add('text-green-700'); \n    } else {\n      wordSpan.textContent = `${guessedWord} [${originalWord}] `; \n      wordSpan.classList.add('text-red-700'); \n    }\n\n    input.parentElement?.insertBefore(wordSpan, input);\n    input.remove();\n  });\n\n  const neededToPass = Math.ceil(totalCount * 0.6);\n  resultArea.classList.remove('text-green-700', 'text-red-700');\n\n  if (timedOut) {\n    resultArea.textContent = `Time's up! You got ${correctCount}/${totalCount} correct.`;\n    resultArea.classList.add(correctCount >= neededToPass ? 'text-green-700' : 'text-red-700', 'text-shadow-typewriter');\n  } else {\n    resultArea.textContent = `${correctCount}/${totalCount} correct.`;\n    resultArea.classList.add(correctCount >= neededToPass ? 'text-green-700' : 'text-red-700', 'text-shadow-typewriter');\n  }\n\n  if (correctCount >= neededToPass) {\n      round++;\n      blanksCount++;\n      if (resultArea) resultArea.textContent += ` Starting Round ${round} with ${blanksCount} blanks in 8 seconds...`;\n  } else {\n      if (resultArea) resultArea.textContent += ` Getting a new passage in 8 seconds...`;\n  }\n\n  if (submitBtn) submitBtn.disabled = true;\n  if (hintBtn) hintBtn.disabled = true;\n\n  if (correctCount >= neededToPass) {\n    setTimeout(() => startRound(false), 8000);\n  } else {\n    setTimeout(() => startRound(true), 8000);\n  }\n}\n","// --- Constants and Config ---\n// Flag to force fallback mode even with valid API key (for debugging)\nconst FORCE_FALLBACK = false; // Using the provided API key\n\n// Empty stub functions for timer (since we're removing timer functionality)\nfunction startTimer() {\n  // Timer functionality removed\n}\n\nfunction stopTimer() {\n  // Timer functionality removed\n}\n\nimport { debugLog } from '@/utils/debugLog';\n// Import the environment configuration utilities\nimport { getEnvironmentConfig, isUsingUserProvidedApiKey } from '@/utils/environmentConfig';\n// getGutenbergBookData and GutendexBookDetails are no longer used here as metadata\n// is fetched by the web-enabled LLM directly in fetchGutenbergPassage.\n// Other Gutendex types like GutendexResponse, SearchGutenbergBooksArgs are not directly used in main.ts anymore.\n// import { getGutenbergBookData, GutendexBookDetails } from '@/services/gutenbergService'; // This line is removed\nimport { runAgenticLoop, tools as llmTools, OpenRouterMessage, ToolDefinition } from '@/services/llmService';\n// Import game logic functions and state, including startRound and handleSubmission\nimport { \n  chooseRedactions, extractKeyTerms, renderRound, initializeGameDOMElements, \n  paragraphsWords, redactedIndices, round as gameRound, blanksCount as gameBlanksCount, \n  hintsRemaining as gameHintsRemaining, hintedBlanks as gameHintedBlanks, \n  resetGame as gameLogicResetGame, \n  ParagraphCache, ParagraphCacheItem, \n  startRound as gameLogicStartRound, \n  handleSubmission as gameLogicHandleSubmission\n} from '@/services/gameLogic';\n\n// --- Type Definitions ---\n// Local OpenRouterMessage, ToolCallFunction, ToolCall, ToolParameterProperty, ToolDefinition are removed.\n// Local GutendexBook, GutendexResponse, SearchGutenbergBooksArgs are removed.\n// ParagraphCacheItem and ParagraphCache are moved to gameLogic.ts\n\n// LLM interaction logic (callLLM, getToolResponse, runAgenticLoop, tools array, TOOL_MAPPING)\n// is now imported from llmService.ts or handled within it.\n// The local logToolCall can be removed if not used elsewhere or can be kept if still needed for other debugging.\n// For now, let's assume it's not needed as llmService has its own.\n\n// --- Game Specific API Functions ---\n// fetchGutenbergPassage is now exported for use in gameLogic.ts\ninterface PassageData {\n  paragraphs: string[];\n  metadata: {\n    title: string;\n    author: string;\n    id: number;\n    century?: string;\n  } | null;\n}\n\nexport async function fetchGutenbergPassage(\n  category: string | null = null, \n  author: string | null = null,\n  century: string | null = null,\n  attemptedBookIds: number[] = [] // Keep track of books already tried\n): Promise<PassageData | null> {\n  const MAX_RETRIES = 3;\n  debugLog(\"Fetching Gutenberg passage\", { category, author, century, attempt: attemptedBookIds.length + 1 });\n\n  // CHECK 1: Allow real Gutenberg fetching when possible\n  // Only use fallback when necessary (GitHub Pages, missing API key)\n  const TEMP_FORCE_FALLBACK = false; // Enable real Gutenberg fetching\n  \n  // Check for API key and environment\n  const hasValidApiKey = Boolean(getEnvironmentConfig().OPENROUTER_API_KEY);\n  const isUsingCustomKey = isUsingUserProvidedApiKey();\n  const isGitHubPages = window.location.hostname.includes('github.io');\n  \n  debugLog(\"Environment check\", { \n    hasValidApiKey, \n    isUsingCustomKey,\n    isGitHubPages, \n    hostname: window.location.hostname,\n    apiKeyFormat: getEnvironmentConfig().OPENROUTER_API_KEY.substring(0, 8) + \"...\",\n    forceFallback: FORCE_FALLBACK,\n    tempForceFallback: TEMP_FORCE_FALLBACK\n  });\n\n  // Use hardcoded examples if:\n  // - we're on GitHub Pages AND don't have a custom key, OR\n  // - have no valid API key, OR\n  // - if we're forcing fallback mode (useful for debugging), OR\n  // - temporarily forcing fallback globally\n  // This fallback logic should be outside the retry loop, as it's a global override.\n  if (!hasValidApiKey || FORCE_FALLBACK || TEMP_FORCE_FALLBACK) {\n    console.warn(\"Using fallback passage due to missing API key or forced fallback.\");\n    let fallbackParagraphs: string;\n    let fallbackMetadata = { title: \"Fallback Passage\", author: \"Anonymous\", id: 0 };\n\n    if (category === 'adventure') {\n      fallbackParagraphs = `The intrepid explorer ventured deeper into the uncharted jungle, sweat beading on his brow as he hacked through the dense undergrowth with his machete. Strange bird calls echoed through the canopy above, and the air hung thick with moisture and the sweet scent of exotic flowers. He knew the lost temple lay somewhere ahead, its ancient stones hiding secrets that had remained untouched for centuries.\n\nAs night fell, he made camp beside a small stream, the gentle gurgling of water over stones providing a soothing counterpoint to the mysterious sounds of the jungle. His maps were worn and faded, but they had served him well thus far. Tomorrow would bring new challenges and, perhaps, the discovery that would cement his place in the annals of exploration.`;\n      fallbackMetadata = { title: \"Adventure Story Excerpt\", author: \"Various Authors\", id: 0 };\n    } else if (category === 'science') {\n      fallbackParagraphs = `The laboratory hummed with the soft whirring of centrifuges and the occasional beep of monitoring equipment. Dr. Chen carefully pipetted the clear solution into a series of test tubes, her steady hands reflecting years of practiced precision. This experiment represented months of theoretical work, and if successful, could fundamentally alter our understanding of cellular regeneration.\n\nScientific discovery has always balanced on the knife-edge between methodical process and creative insight. The greatest breakthroughs often come not from following established protocols, but from the moments when researchers question fundamental assumptions and pursue the unexpected anomalies that appear in their data. It is this combination of discipline and imagination that drives progress forward.`;\n      fallbackMetadata = { title: \"Scientific Musings\", author: \"Various Authors\", id: 0 };\n    } else {\n      // Default paragraphs for any other category or no category\n      fallbackParagraphs = `The ability to think clearly and rationally is essential for making good decisions and solving problems effectively. Critical thinking involves analyzing information objectively and making reasoned judgments based on evidence rather than personal bias or emotional reactions. It requires skills such as attention to detail, logical reasoning, and the willingness to question assumptions.\n\nThroughout history, literature has served as a mirror reflecting the values, concerns, and aspirations of society. Books allow us to experience different perspectives, fostering empathy and understanding across cultural divides. Whether through fiction or non-fiction, the written word preserves human knowledge and invites readers to engage with ideas that may challenge or expand their worldview.`;\n      fallbackMetadata = { title: \"General Knowledge Excerpt\", author: \"Various Authors\", id: 0 };\n    }\n\n    return {\n      paragraphs: fallbackParagraphs.split(/\\n+/).filter(p => p.trim().length > 0),\n      metadata: fallbackMetadata\n    };\n  }\n\n  // Retry loop\n  for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {\n    debugLog(`Fetch attempt ${attempt + 1} of ${MAX_RETRIES}. Attempted IDs: ${attemptedBookIds.join(', ')}`);\n\n    const queryParts = [];\n    if (author) queryParts.push(`by author \"${author}\"`);\n    \n    if (category) {\n      if (category.includes('/')) {\n        const categoryCode = category.split('/')[1];\n        if (categoryCode) {\n          queryParts.push(`in the Gutenberg bookshelf ID \"${categoryCode}\"`);\n          debugLog(`Using bookshelf ID \"${categoryCode}\" from category \"${category}\".`);\n        } else {\n          debugLog(`Could not extract bookshelf ID from category \"${category}\". Category will be ignored.`);\n        }\n      } else {\n        queryParts.push(`in the category \"${category}\"`);\n      }\n    }\n\n    if (century) {\n      const centuryNumber = parseInt(century);\n      if (!isNaN(centuryNumber)) {\n          queryParts.push(`from the ${centuryNumber + 1}th century`);\n      }\n    }\n\n    let queryString = queryParts.join(' ');\n    let baseQueryInstruction: string;\n\n    if (queryParts.length > 0) {\n      baseQueryInstruction = `from Project Gutenberg ${queryString}`;\n      debugLog(\"Specific criteria provided: using standard query string.\");\n    } else {\n      // For the initial fetch when no user settings are provided,\n      // use a more specific instruction to encourage true randomness and variety.\n      baseQueryInstruction = \"from a truly random book in classic literature, prioritizing high variety and diverse selections. Please try to pick something unexpected or less common to ensure a unique experience.\";\n      debugLog(\"No specific criteria: using new enhanced random query string for initial fetch.\");\n    }\n    \n    let retryInstructions = \"\";\n    if (attempt > 0) {\n      retryInstructions = ` This is attempt ${attempt + 1}. Please ensure you select a *different* book than previous attempts.`;\n    }\n    if (attemptedBookIds.length > 0) {\n      retryInstructions += ` Avoid Project Gutenberg IDs: ${attemptedBookIds.join(', ')}.`;\n    }\n    \n    const userQuery = `Please provide a short literary passage (2-3 paragraphs) from Project Gutenberg.\n${baseQueryInstruction ? `Ideally, the passage should be ${baseQueryInstruction}.` : 'The passage can be from any classic literary work.'}\n${retryInstructions}\nInclude the title, author, and Project Gutenberg ID if available.\n\nFormat suggestion:\nTitle: [Book Title]\nAuthor: [Book Author]\nID: [Book ID]\nPassage:\n[The passage text]\n\nIf no passage can be found, please indicate that. Focus on returning a passage, even if all criteria cannot be perfectly met.`;\n\n    const messages: OpenRouterMessage[] = [\n      { role: 'system', content: 'You are an assistant that helps find and display literary passages from Project Gutenberg. Please provide the passage text along with its title, author, and Project Gutenberg ID if available. Prioritize finding a passage, even if specific search criteria (like category, author, or century) are suggestions and cannot all be met. Avoid adding commentary or analysis not present in the original text.' },\n      { role: 'user', content: userQuery }\n    ];\n\n    try {\n      // Determine temperature: higher for purely random, default otherwise\n      const temperature = (queryParts.length === 0) ? 1.2 : undefined;\n      debugLog(`LLM call (attempt ${attempt + 1}) with temperature: ${temperature === undefined ? 'default' : temperature}`);\n      const llmResponseContent = await runAgenticLoop(messages, [], temperature); \n\n      if (!llmResponseContent) {\n        console.error(`LLM call (attempt ${attempt + 1}) returned no content.`);\n        if (attempt === MAX_RETRIES - 1) return null; // Last attempt failed\n        await new Promise(resolve => setTimeout(resolve, 1000)); // Wait before retrying\n        continue; // Next attempt\n      }\n\n      debugLog(`LLM Web Search Response for Passage (attempt ${attempt + 1}):`, llmResponseContent);\n\n      let bookTitle = \"Unknown Title\";\n      let bookAuthor = \"Unknown Author\";\n      let bookId: number | null = null;\n      let passageText = \"\";\n\n      const titleMatch = llmResponseContent.match(/Title:\\s*(.*)/i);\n      if (titleMatch && titleMatch[1]) bookTitle = titleMatch[1].trim();\n\n      const authorMatch = llmResponseContent.match(/Author:\\s*(.*)/i);\n      if (authorMatch && authorMatch[1]) bookAuthor = authorMatch[1].trim();\n\n      const idMatch = llmResponseContent.match(/ID:\\s*(\\d+)/i);\n      if (idMatch && idMatch[1]) bookId = parseInt(idMatch[1], 10);\n\n      // Add bookId to attemptedBookIds if valid and not already present\n      if (bookId !== null && !attemptedBookIds.includes(bookId)) {\n        attemptedBookIds.push(bookId);\n      }\n      \n      const passageMarker = \"Passage:\";\n      const passageStartIndex = llmResponseContent.indexOf(passageMarker);\n\n      if (passageStartIndex !== -1) {\n        passageText = llmResponseContent.substring(passageStartIndex + passageMarker.length).trim();\n      } else {\n        let lastMetadataIndex = 0;\n        if (titleMatch) lastMetadataIndex = Math.max(lastMetadataIndex, (titleMatch.index || 0) + titleMatch[0].length);\n        if (authorMatch) lastMetadataIndex = Math.max(lastMetadataIndex, (authorMatch.index || 0) + authorMatch[0].length);\n        if (idMatch) lastMetadataIndex = Math.max(lastMetadataIndex, (idMatch.index || 0) + idMatch[0].length);\n        if (lastMetadataIndex > 0 && lastMetadataIndex < llmResponseContent.length) {\n          passageText = llmResponseContent.substring(lastMetadataIndex).trim();\n        } else if (!titleMatch && !authorMatch && !idMatch) {\n          passageText = llmResponseContent.trim();\n          debugLog(\"No metadata markers found, assuming entire response is passage text.\");\n        }\n      }\n      \n      if (!passageText || llmResponseContent.toLowerCase().includes(\"no suitable passage found\")) {\n          console.warn(`Attempt ${attempt + 1}: Could not extract passage text or LLM indicated no passage found.`);\n          if (attempt === MAX_RETRIES - 1) return null; // Last attempt failed\n          await new Promise(resolve => setTimeout(resolve, 1000)); // Wait before retrying\n          continue; // Next attempt\n      }\n\n      let paragraphs = passageText\n        .split(/\\n\\s*\\n/)\n        .map((p: string) => p.trim())\n        .filter((p: string) => p.length > 150 && !p.startsWith('Project Gutenberg') && !p.startsWith('***') && !p.includes('*** END OF ') && !p.startsWith('THE END') && !p.includes('www.gutenberg.org') && !/^\\*+$/.test(p))\n        .slice(0, 10);\n      \n      if (paragraphs.length < 2) {\n        debugLog(`Attempt ${attempt + 1}: First parsing didn't yield enough paragraphs, trying alternative.`);\n        paragraphs = passageText\n          .replace(/\\r\\n/g, '\\n')\n          .split(/(?:\\n\\s*){2,}/)\n          .map((p: string) => p.replace(/\\n/g, ' ').trim())\n          .filter((p: string) => p.length > 150 && !p.includes('Project Gutenberg'))\n          .slice(0, 10);\n      }\n      \n      paragraphs.sort((a, b) => {\n        const scoreA = Math.min(a.length, 1000) - Math.max(0, 2000 - a.length) + (a.match(/[.!?][\\s\"']/) ? 200 : 0);\n        const scoreB = Math.min(b.length, 1000) - Math.max(0, 2000 - b.length) + (b.match(/[.!?][\\s\"']/) ? 200 : 0);\n        return scoreB - scoreA;\n      });\n      \n      paragraphs = paragraphs.slice(0, 2);\n      \n      if (paragraphs.length === 0) {\n        debugLog(`Attempt ${attempt + 1}: Failed to extract suitable paragraphs after all parsing attempts.`);\n      }\n\n      // If we have at least one good paragraph, proceed. Otherwise, retry.\n      if (paragraphs.length > 0) { // Changed from paragraphs.length < 2 to paragraphs.length > 0 for success condition\n        console.log(`Attempt ${attempt + 1}: Successfully extracted ${paragraphs.length} paragraphs.`);\n        return {\n          paragraphs: paragraphs,\n          metadata: { \n            title: bookTitle,\n            author: bookAuthor,\n            id: bookId !== null ? bookId : 0 \n          }\n        };\n      } else {\n        console.warn(`Attempt ${attempt + 1}: Could only extract ${paragraphs.length} suitable paragraphs. Retrying if attempts remain.`);\n        // No suitable paragraphs found in this attempt, loop will continue if attempts < MAX_RETRIES\n      }\n\n    } catch (error) {\n      console.error(`Error in fetchGutenbergPassage (LLM web search, attempt ${attempt + 1}):`, error);\n      // Loop will continue if attempts < MAX_RETRIES\n    }\n    if (attempt < MAX_RETRIES - 1) {\n      await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1))); // Exponential backoff might be better\n    }\n  } // End of retry loop\n\n  console.error(\"Failed to fetch a suitable passage after all retries.\");\n  return null; // Indicate failure after all retries\n}\n\n// are now imported from and managed by gameLogic.ts.\n// We use aliasing for round, blanksCount, hintsRemaining, hintedBlanks to avoid naming conflicts if needed,\n// though direct usage of imported names is fine if there are no conflicts.\n\n// Function to reset game state for a new game (not just a new round)\nfunction resetGame() {\n  // We'll use the imported resetGame function from gameLogic\n  gameLogicResetGame();\n\n  // Additional UI updates if needed\n  if (gameArea) gameArea.innerHTML = '';\n  if (resultArea) resultArea.textContent = '';\n  if (roundInfo) roundInfo.textContent = '';\n  if (bibliographicArea) bibliographicArea.innerHTML = '';\n  stopTimer();\n}\n\n// Cache DOM elements\nlet bibliographicArea: HTMLElement, gameArea: HTMLElement, resultArea: HTMLElement, hintBtn: HTMLButtonElement,\n    submitBtn: HTMLButtonElement, roundInfo: HTMLElement, newTextBtn: HTMLButtonElement, welcomeOverlay: HTMLElement, startGameBtn: HTMLButtonElement;\n\nfunction querySelectorSafe<T extends Element>(selector: string, container: Document | Element = document): T | null {\n    const element = container.querySelector(selector);\n    if (!element) {\n        console.warn(`Element with selector \"${selector}\" not found.`);\n        return null;\n    }\n    return element as T;\n}\n\nfunction cacheDOMElements() {\n    try {\n        bibliographicArea = querySelectorSafe<HTMLElement>('#bibliographic-area') || document.createElement('div');\n        gameArea = querySelectorSafe<HTMLElement>('#game-area') || document.createElement('div');\n        resultArea = querySelectorSafe<HTMLElement>('#result') || document.createElement('div');\n        hintBtn = querySelectorSafe<HTMLButtonElement>('#hint-btn') || document.createElement('button');\n        submitBtn = querySelectorSafe<HTMLButtonElement>('#submit-btn') || document.createElement('button');\n        roundInfo = querySelectorSafe<HTMLElement>('#round-info') || document.createElement('div');\n        \n        // Settings elements are now handled by Preact components\n        newTextBtn = querySelectorSafe<HTMLButtonElement>('#new-text-btn') || document.createElement('button');\n        \n        // Check for welcome overlay elements (may not exist in inference.html)\n        welcomeOverlay = querySelectorSafe<HTMLElement>('#welcome-overlay') || document.createElement('div');\n        startGameBtn = querySelectorSafe<HTMLButtonElement>('#start-game-btn') || document.createElement('button');\n        \n        console.log(\"DOM Elements cached successfully:\", {\n            gameAreaFound: !!document.querySelector('#game-area'),\n            welcomeOverlayFound: !!document.querySelector('#welcome-overlay'),\n            startGameBtnFound: !!document.querySelector('#start-game-btn')\n        });\n\n        // Initialize DOM elements for gameLogic service\n        initializeGameDOMElements({\n            gameArea,\n            roundInfo,\n            submitBtn,\n            hintBtn,\n            resultArea,\n            bibliographicArea\n        });\n    } catch (error) {\n        console.error(\"Error caching DOM elements:\", error);\n    }\n}\n\n// Make functions globally available for legacy code and avoiding circular imports\nif (typeof window !== 'undefined') {\n    (window as any).startRound = gameLogicStartRound;\n    // findRelatedBooks is removed\n    console.log(\"Added global functions to window object\");\n}\n\n// Initialize the application when the DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    // Cache DOM elements\n    cacheDOMElements();\n\n    // Set up event listeners\n    // The startGameBtn event listener is removed from here as it's handled by the WelcomeOverlay component's onStart prop\n    // and the app.tsx component.\n\n    newTextBtn.addEventListener('click', async () => {\n      // Fetch a new passage without resetting game state, forcing a new passage\n      await gameLogicStartRound(true);\n    });\n    submitBtn.addEventListener('click', () => gameLogicHandleSubmission());\n    \n    // Show welcome overlay\n    // The welcome overlay visibility is now primarily managed by the App component's state\n    // and the WelcomeOverlay component itself.\n    // However, ensuring it's initially visible if not handled by Preact's initial render might still be useful.\n    // For now, let's assume Preact handles initial visibility correctly.\n    // If issues arise, we might need to revisit this.\n    // welcomeOverlay.classList.remove('hidden'); // This line can likely be removed or conditionalized\n});\n","// src/services/llmService.ts\n\nimport { debugLog } from '@/utils/debugLog';\nimport { getEnvironmentConfig } from '@/utils/environmentConfig';\n// Removed import of searchGutenbergBooks and SearchGutenbergBooksArgs as they are no longer used.\n\n// --- Type Definitions (subset relevant to this service) ---\nexport interface OpenRouterMessage {\n  role: 'system' | 'user' | 'assistant' | 'tool';\n  content?: string | null;\n  tool_calls?: ToolCall[];\n  tool_call_id?: string;\n  name?: string; // for tool role if function name\n}\n\nexport interface ToolCallFunction {\n  name: string;\n  arguments: string; // JSON string\n}\n\nexport interface ToolCall {\n  id: string;\n  type: 'function';\n  function: ToolCallFunction;\n}\n\nexport interface ToolParameterProperty {\n  type: string;\n  items?: { type: string };\n  description: string;\n}\n\nexport interface ToolDefinition {\n  type: 'function';\n  function: {\n    name: string;\n    description: string;\n    parameters: {\n      type: 'object';\n      properties: Record<string, ToolParameterProperty>;\n      required: string[];\n    };\n  };\n}\n\n// --- Tool Definitions & Mappings (specific to LLM service) ---\n// Tools for Gutenberg search and text fetching are removed as the :online model handles this.\nexport const tools: ToolDefinition[] = [\n  // No tools defined here anymore, or only non-Gutenberg related tools if any exist.\n];\n\n// TOOL_MAPPING is no longer needed if no tools are defined, or will only contain non-Gutenberg tools.\nexport const TOOL_MAPPING: Record<string, (args: any) => Promise<object>> = {\n  // Empty or contains other tools\n};\n\n// For debugging tool calls\nfunction logToolCall(message: string, data: any): void {\n  // Using debugLog for consistency, assuming it's globally available or passed/imported\n  debugLog(`[LLM Service Tool Call] ${message}`, data);\n}\n\n/**\n * Calls the OpenRouter LLM API with the given messages and tools.\n * @param messages Array of messages for the LLM.\n * @param currentTools Optional array of tool definitions for the LLM.\n * @param temperature Optional temperature setting for the LLM.\n * @returns A promise that resolves to the assistant's response message.\n */\nexport async function callLLM(messages: OpenRouterMessage[], currentTools?: ToolDefinition[], temperature?: number): Promise<OpenRouterMessage> {\n  const body: {\n    model: string;\n    messages: OpenRouterMessage[];\n    tools?: ToolDefinition[];\n    tool_choice?: 'auto' | 'none' | { type: string; function: { name: string } };\n    temperature?: number;\n  } = {\n    model: 'google/gemini-flash-1.5:online', // Using a web-enabled Gemini model\n    messages,\n    // Web search is enabled by :online, specific plugin config might not be needed\n    // unless we want to customize search_prompt or max_results.\n    // For now, relying on default :online behavior.\n  };\n\n  if (temperature !== undefined) {\n    body.temperature = temperature;\n    debugLog(\"LLM Service: Using custom temperature\", temperature);\n  }\n\n  // If tools are provided, add them. Otherwise, the model will rely on web search.\n  if (currentTools && currentTools.length > 0) {\n    body.tools = currentTools;\n    body.tool_choice = 'auto'; // Let the model decide when to use tools\n    debugLog(\"LLM Service: Using tools\", currentTools);\n  } else {\n    // If no specific tools, ensure tool_choice is not set or is 'none' if we want to prevent any tool use.\n    // For web search, 'auto' or omitting tool_choice is fine.\n    // The :online suffix handles the web search plugin implicitly.\n    debugLog(\"LLM Service: No specific tools provided, relying on web search via :online model suffix.\");\n  }\n\n  debugLog(\"LLM Service: OpenRouter API Request\", body);\n\n  try {\n    const apiKey = getEnvironmentConfig().OPENROUTER_API_KEY;\n    \n    const response = await fetch(\n      'https://openrouter.ai/api/v1/chat/completions',\n      {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${apiKey}`,\n          'Content-Type': 'application/json',\n          'HTTP-Referer': typeof window !== 'undefined' ? window.location.href : '', // Handle server-side if needed\n          'X-Title': 'Cloze', // App-specific title\n        },\n        body: JSON.stringify(body),\n      }\n    );\n\n    if (!response.ok) {\n      let errorData;\n      try {\n        errorData = await response.json();\n      } catch (e) {\n        errorData = await response.text();\n      }\n      const errorMessage = (typeof errorData === 'object' && errorData?.error?.message) ? errorData.error.message : (typeof errorData === 'string' ? errorData : 'Unknown API error');\n      console.error(\"LLM Service: OpenRouter API Error:\", response.status, errorMessage);\n      throw new Error(`OpenRouter API Error: ${response.status} - ${errorMessage}`);\n    }\n\n    const data = await response.json();\n    debugLog(\"LLM Service: OpenRouter API Response\", data);\n\n    if (!data.choices || !data.choices[0] || !data.choices[0].message) {\n      console.error(\"LLM Service: Invalid response structure from OpenRouter:\", data);\n      throw new Error(\"Invalid response structure from OpenRouter.\");\n    }\n    return data.choices[0].message as OpenRouterMessage;\n  } catch (error) {\n    console.error(\"LLM Service: Error calling OpenRouter API:\", error);\n    throw error; // Re-throw to be handled by the caller\n  }\n}\n\n/**\n * Processes tool calls from an assistant's response.\n * @param assistantResponse The assistant's message containing tool calls.\n * @returns A promise that resolves to a message with the tool's response.\n */\nexport async function getToolResponse(assistantResponse: OpenRouterMessage): Promise<OpenRouterMessage> {\n  if (!assistantResponse.tool_calls || assistantResponse.tool_calls.length === 0) {\n    throw new Error(\"Assistant response does not contain tool calls.\");\n  }\n\n  const toolCall = assistantResponse.tool_calls[0]; // Assuming one tool call for now\n  const toolName = toolCall.function.name;\n  logToolCall(\"Received tool call\", { toolName, toolCallId: toolCall.id });\n\n  let toolArgs;\n  try {\n    toolArgs = JSON.parse(toolCall.function.arguments);\n    logToolCall(\"Parsed tool arguments\", toolArgs);\n  } catch (error) {\n    const errorObj = error as Error;\n    console.error(\"LLM Service: Failed to parse tool arguments:\", errorObj);\n    return {\n      role: 'tool',\n      tool_call_id: toolCall.id,\n      name: toolName,\n      content: JSON.stringify({ error: `Invalid JSON in tool arguments: ${errorObj.message}` }),\n    };\n  }\n\n  const toolFunction = TOOL_MAPPING[toolName];\n  if (!toolFunction) {\n    console.error(`LLM Service: Tool ${toolName} not found in TOOL_MAPPING.`);\n    return {\n      role: 'tool',\n      tool_call_id: toolCall.id,\n      name: toolName,\n      content: JSON.stringify({ error: `Tool ${toolName} not found.` }),\n    };\n  }\n\n  try {\n    logToolCall(\"Executing tool function\", { name: toolName });\n    const toolResult = await toolFunction(toolArgs);\n    logToolCall(\"Tool execution result\", toolResult);\n    return {\n      role: 'tool',\n      tool_call_id: toolCall.id,\n      name: toolName,\n      content: JSON.stringify(toolResult),\n    };\n  } catch (error: any) {\n    console.error(`LLM Service: Error executing tool ${toolName}:`, error);\n    return {\n      role: 'tool',\n      tool_call_id: toolCall.id,\n      name: toolName,\n      content: JSON.stringify({ error: `Error executing tool ${toolName}: ${error.message}` }),\n    };\n  }\n}\n\n/**\n * Runs an agentic loop with the LLM, handling tool calls.\n * @param initialMessages The initial set of messages to start the loop.\n * @param loopTools The tools available for the LLM to use in this loop.\n * @param temperature Optional temperature setting for the LLM calls within the loop.\n * @returns A promise that resolves to the final assistant content or an error message.\n */\nexport async function runAgenticLoop(initialMessages: OpenRouterMessage[], loopTools: ToolDefinition[], temperature?: number): Promise<string | null> {\n  let messages: OpenRouterMessage[] = [...initialMessages];\n  const MAX_ITERATIONS = 5; // Prevent infinite loops\n\n  for (let i = 0; i < MAX_ITERATIONS; i++) {\n    debugLog(`LLM Service: Agentic Loop Iteration ${i + 1}`);\n    const assistantResponse = await callLLM(messages, loopTools, temperature); // Pass temperature\n    messages.push(assistantResponse);\n\n    if (assistantResponse.tool_calls && assistantResponse.tool_calls.length > 0) {\n      // Potentially handle multiple tool calls in the future if needed\n      const toolResponseMessage = await getToolResponse(assistantResponse);\n      messages.push(toolResponseMessage);\n    } else {\n      // No tool calls, loop finishes, return assistant's content\n      return assistantResponse.content ?? null;\n    }\n  }\n\n  console.warn(\"LLM Service: Agentic loop reached max iterations.\");\n  const lastMessage = messages.length > 0 ? messages[messages.length - 1] : null;\n  if (lastMessage && lastMessage.role === 'assistant' && lastMessage.content) {\n    return lastMessage.content;\n  }\n  return \"Agentic loop completed without a final assistant message or an error occurred.\";\n}\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$4a4e2fe1326f8d10$export$5911d6599ccd5587","$4a4e2fe1326f8d10$export$743c700ce157bd09","$4a4e2fe1326f8d10$export$2efac152e5544c6f","$gAFfX","$4a4e2fe1326f8d10$export$9b37f4151ec193f8","window","location","hostname","includes","protocol","remote","userProvidedKey","localStorage","getItem","isUserKeyValid","Boolean","startsWith","length","defaultKey","atob","apiKey","debugLog","isRemoteInterface","usingUserKey","keyFormat","substring","OPENROUTER_API_KEY","IS_REMOTE_INTERFACE","key","trimmedKey","trim","setItem","$c14002d12a315116$export$140d7860bc6d1e6e","message","data","timestamp","Date","toISOString","console","log","undefined","jsonData","JSON","stringify","value","HTMLElement","tagName","error","$3c0857659fbe7bcd$export$9d09d44d755232c3","$3c0857659fbe7bcd$export$8a9e2a13fbf8faaf","$3c0857659fbe7bcd$export$b5f85e4b788b2112","$3c0857659fbe7bcd$export$f4978f2673be205b","$64gHy","$3c0857659fbe7bcd$var$paragraphCache","cache","maxSize","keys","oldestKey","now","warn","item","saved","parse","$3c0857659fbe7bcd$export$a49bff6fbcf3a3c9","words","count","indices","functionWords","Set","scoredWords","map","word","index","score","cleanWord","toLowerCase","replace","has","toUpperCase","match","Math","random","sort","a","b","actualCount","min","candidatePoolSize","topCandidates","slice","randomIndex","floor","selectedWord","splice","push","$3c0857659fbe7bcd$export$7270d0e0b4d16214","$3c0857659fbe7bcd$export$8d792ae58277cf50","$3c0857659fbe7bcd$export$2077e0241d6afd3c","$3c0857659fbe7bcd$export$f69a3a7a70d5284b","$3c0857659fbe7bcd$export$a6ae94fc66d9d8b3","$3c0857659fbe7bcd$export$71a5d0721a141a3f","$3c0857659fbe7bcd$export$8ea65ab2a8063b73","$3c0857659fbe7bcd$var$domElements","elements","$3c0857659fbe7bcd$export$f9a124f5758d48a2","gameArea","roundInfo","submitBtn","hintBtn","resultArea","totalBlanks","textContent","innerHTML","disabled","pIdx","paragraphElement","document","createElement","className","style","maxWidth","overflowWrap","appendChild","forEach","idx","input","type","dataset","String","paragraph","placeholder","addEventListener","classList","add","setTimeout","remove","Array","from","querySelectorAll","every","i","createTextNode","paragraphIdx","Number","wordIdx","blankKey","onclick","originalWord","hintText","hintDiv","body","closeHint","removeChild","querySelector","target","wordSpan","totalRedactedCount","startTimer","applyTypewriterEffect","bibliographicArea","clear","stopTimer","forceNewPassage","category","author","century","cacheKey","toString","cachedPassage","fetchedPassageData","fetchGutenbergPassage","paragraphs","split","filter","w","metadata","some","book","unshift","pop","historyHtml","title","metaElements","el","totalWords","actualBlanksCount","firstParaBlanks","newRedactionsPara0","r","secondParaBlanks","newRedactionsPara1","parsedCache","isArray","passageData","timedOut","inputs","correctCount","totalCount","guessedWord","originalWordClean","guessedWordClean","parentElement","insertBefore","neededToPass","ceil","$46b0125df3b201f4$var$bibliographicArea","$46b0125df3b201f4$var$gameArea","$46b0125df3b201f4$var$resultArea","$46b0125df3b201f4$var$hintBtn","$46b0125df3b201f4$var$submitBtn","$46b0125df3b201f4$var$roundInfo","$46b0125df3b201f4$var$newTextBtn","$46b0125df3b201f4$export$75740e8299ebcb60","$6nwBV","$84ah7","$59ye1","attemptedBookIds","attempt","hasValidApiKey","getEnvironmentConfig","isUsingCustomKey","isUsingUserProvidedApiKey","isGitHubPages","apiKeyFormat","forceFallback","tempForceFallback","fallbackParagraphs","fallbackMetadata","p","baseQueryInstruction","join","queryParts","categoryCode","centuryNumber","parseInt","isNaN","queryString","retryInstructions","messages","role","content","temperature","llmResponseContent","runAgenticLoop","MAX_RETRIES","Promise","resolve","bookTitle","bookAuthor","bookId","passageText","titleMatch","authorMatch","idMatch","passageMarker","passageStartIndex","indexOf","lastMetadataIndex","max","test","scoreA","scoreB","$46b0125df3b201f4$var$querySelectorSafe","selector","container","element","startRound","gameAreaFound","welcomeOverlayFound","startGameBtnFound","initializeGameDOMElements","handleSubmission","$5df6aadcacb3e0b8$export$24a8f16ac63dee91","$5df6aadcacb3e0b8$export$cb0654e594b33ecc","$5df6aadcacb3e0b8$var$logToolCall","$5df6aadcacb3e0b8$export$783923861e6b7ea4","currentTools","model","tools","tool_choice","response","fetch","method","headers","Authorization","href","ok","errorData","json","text","errorMessage","status","choices","$5df6aadcacb3e0b8$export$8e4a45ddb5eaee59","assistantResponse","toolArgs","tool_calls","toolCall","toolName","function","name","toolCallId","arguments","tool_call_id","errorObj","toolFunction","toolResult","initialMessages","loopTools","toolResponseMessage","lastMessage"],"version":3,"file":"inference.39e3d91a.js.map"}